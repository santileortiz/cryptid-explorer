<!doctype html>
<html lang="en">
<head>
	<meta charset="utf-8" />
	<meta name="viewport" content="width=device-width, initial-scale=1" />
	<title>Cryptid Board Analyzer (Lightweight)</title>
	<style>
		:root { --pad: 10px; --bg: #0f172a; --panel: #111827; --muted: #94a3b8; --text: #e5e7eb; }
		html, body { height: 100%; }
		body {
			margin: 0; font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
			background: var(--bg); color: var(--text); display: grid; grid-template-columns: 320px 1fr 360px;
			grid-template-rows: auto 1fr; grid-template-areas:
				"header header header"
				"left canvas right";
			gap: 10px; padding: var(--pad);
		}
		h1 { font-size: 18px; margin: 0; letter-spacing: .2px; }
		#header { grid-area: header; display:flex; align-items:center; gap:12px; background:var(--panel); border-radius:12px; padding:10px 14px; }
		.badge { font-size: 12px; color: var(--bg); background: #a7f3d0; border-radius: 999px; padding: 2px 8px; }
		.panel { background: var(--panel); border-radius: 12px; padding: 10px; }
		#left { grid-area: left; display: grid; gap: 10px; align-content: start; }
		#right { grid-area: right; display: grid; gap: 10px; align-content: start; }
		#canvasWrap { grid-area: canvas; position: relative; background: #0b1220; border-radius: 12px; overflow: hidden; }
		label { font-size: 12px; color: var(--muted); }
		select, button, input[type="number"], textarea, input[type="text"] { width: 100%; background: #0b1220; color: var(--text); border: 1px solid #243041; border-radius: 8px; padding: 8px; font: inherit; }
		button { cursor: pointer; }
		button.inline { width: auto; padding: 6px 10px; border-radius: 8px; }
		.group { display: grid; gap: 6px; }
		.row { display:flex; gap:8px; align-items:center; flex-wrap: wrap; }
		.small { font-size: 12px; color: var(--muted); }
		.kbd { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; background:#0b1220; border:1px solid #223048; padding:2px 6px; border-radius:6px; }
		legend { font-size: 12px; color: var(--muted); margin-bottom: 6px; }
		.ruleList { display:grid; gap:6px; max-height: 42vh; overflow:auto; border:1px solid #223048; border-radius:8px; padding:8px; }
		.ruleItem { display:grid; grid-template-columns: 1fr 42px; gap:6px; align-items:center; }
		#hexsvg { width:100%; height:100%; display:block; }
		#canvasWrap, #hexsvg, #hexsvg * { -webkit-user-select: none; user-select: none; }
		#legend { display:grid; grid-template-columns: repeat(5, minmax(0,1fr)); gap:6px; }
		.swatch { display:flex; gap:6px; align-items:center; background:#0b1220; border:1px solid #243041; border-radius:8px; padding:6px; justify-content:center; }
		.sw { width:14px; height:14px; border-radius:3px; border:1px solid #0007; }
		ul.flat { list-style:none; padding:0; margin:0; display:flex; gap:8px; flex-wrap:wrap; }
		ul.flat li { padding:4px 8px; border:1px solid #223048; border-radius:8px; background:#0b1220; font-size:12px; }
		textarea.code { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace; height: 160px; }
		hr { border:0; border-top:1px solid #223048; margin:8px 0; }
		.colorChip { width:14px; height:14px; border-radius:999px; display:inline-block; vertical-align:middle; border:1px solid #0007; }
	</style>
</head>
<body>
	<header id="header" class="panel">
		<h1>Cryptid Analyzer</h1>
		<span class="badge">flat-top hex ¬∑ 12√ó9</span>
		<div class="small">
			Click = paint terrain ¬∑ <span class="kbd">Shift</span>+Click = toggle marker (animal/structure) ¬∑
			<span class="kbd">Alt</span>+Click = erase ¬∑ Evaluate draws outlines for each player's assigned rule; the single cell satisfying all assigned rules is highlighted.
		</div>
	</header>

	<section id="left">
		<div class="panel group">
			<label for="players">Players</label>
			<select id="players">
				<option value="3">3 players</option>
				<option value="4" selected>4 players</option>
				<option value="5">5 players</option>
			</select>
			<div class="row">
				<button id="evaluate" class="inline">Evaluate</button>
				<button id="clearHighlights" class="inline">Clear</button>
			</div>
			<div class="small" id="resultSummary">‚Äî</div>
		</div>

		<div class="panel group">
			<legend>Board</legend>
			<legend>Paint</legend>
			<ul class="flat" id="terrainPalette"></ul>
			<legend>Markers</legend>
			<ul class="flat" id="markerPalette"></ul>
		</div>

		<div class="panel group">
			<legend>Tile arrangement (2√ó3)</legend>
			<input id="arrangementStr" class="code" placeholder="e.g., 6 3 1 5 4 2" value="1 2 3 4 5 6">
			<div class="row">
				<button id="applyArrangement" class="inline">Apply</button>
				<button id="toggleTileLabels" class="inline">Toggle labels</button>
			</div>
			
		</div>

		<div class="panel group">
			<legend>Import / Export</legend>
			<div class="row">
				<button id="exportBoard" class="inline">Export Board JSON</button>
				<button id="importBoard" class="inline">Import</button>
			</div>
			<textarea id="boardJSON" class="code" placeholder="Board JSON will appear here..."></textarea>
		</div>
	</section>

	<main id="canvasWrap">
		<svg id="hexsvg" viewBox="0 0 1000 1000" role="img" aria-label="Cryptid board"></svg>
	</main>

	<aside id="right">
		<div class="panel group">
			<legend>Rules (filtered by players)</legend>
			<div class="ruleList" id="ruleList"></div>
			<div class="small">Counts update automatically.</div>
		</div>

		<div class="panel group">
			<legend>Players & clues</legend>
			<div id="assignments"></div>
		</div>

		<div class="panel group">
			<legend>Rules JSON (editable)</legend>
			<textarea id="rulesJSON" class="code" spellcheck="false"></textarea>
			<div class="row">
				<button id="applyRules" class="inline">Apply JSON</button>
				<button id="resetRules" class="inline">Reset</button>
			</div>
		</div>

		<div class="panel group">
			<legend>Legend</legend>
			<div id="legend"></div>
		</div>
	</aside>

<script>
// ===== Core data =====
const TERRAIN = /** @type {const} */ (['desert','swamp','mountain','forest','water']);
const ANIMALS = /** @type {const} */ (['bear','cougar']);
const STRUCT_TYPES = /** @type {const} */ (['standing_stone','abandoned_shack']);
const COLORS = /** @type {const} */ (['black','blue','green','white']);

const TERRAIN_COLORS = { desert:'#eab308', swamp:'#a78bfa', mountain:'#9ca3af', forest:'#22c55e', water:'#38bdf8' };
const STRUCT_COLORS = { black:'#111827', blue:'#3b82f6', green:'#22c55e', white:'#e5e7eb' };
const RULE_COLORS = ['#f97316','#22d3ee','#a78bfa','#34d399','#f43f5e','#eab308','#06b6d4','#84cc16'];

const PLAYER_COLORS = { blue:'#3b82f6', red:'#ef4444', green:'#22c55e', purple:'#a78bfa', orange:'#f97316' };
const PLAYER_COLOR_ORDER = ['blue','red','green','purple','orange'];
const DEFAULT_PLAYER_COLORS_BY_COUNT = {3:['blue','red','green'],4:['blue','red','green','purple'],5:['blue','red','green','purple','orange']};
let PLAYER_ASSIGNMENTS = []; // [{color:'blue'|'red'|'green'|'purple'|'orange', ruleId:string|null}]

const ANIMAL_GLYPH = { bear:'üêª', cougar:'üêæ' };

// ===== Types =====
/** @typedef {('desert'|'swamp'|'mountain'|'forest'|'water')} Terrain */
/** @typedef {('bear'|'cougar')} Animal */
/** @typedef {('standing_stone'|'abandoned_shack')} StructureType */
/** @typedef {('black'|'blue'|'green'|'white')} Color */
/** @typedef {{ q:number, r:number, terrain:Terrain, animals:Set<Animal>, structures:Array<{type:StructureType,color:Color}> }} Cell */

// ===== Board =====
const Board = { width:12, height:9, cells:new Map() };
const key = (q,r)=>`${q},${r}`;
function forEachCell(cb){ for(const c of Board.cells.values()) cb(c); }
function cellAt(q,r){ let c=Board.cells.get(key(q,r)); if(!c){ c={q,r,terrain:'water',animals:new Set(),structures:[]}; Board.cells.set(key(q,r),c);} return c; }
function hexDist(a,b){
	// Correct odd-q (vertical columns) distance via cube coords
	function toCube(q,r){
		const x = q;
		const z = r - ((q - (q & 1)) / 2);
		const y = -x - z;
		return {x,y,z};
	}
	const ac = toCube(a.q,a.r);
	const bc = toCube(b.q,b.r);
	const dx = Math.abs(ac.x - bc.x);
	const dy = Math.abs(ac.y - bc.y);
	const dz = Math.abs(ac.z - bc.z);
	return (dx + dy + dz) / 2;
}

// ===== Tiles (2√ó3 grid of 6√ó3 hexes each) =====
const TILE_W = 6, TILE_H = 3;
/** @typedef {{ terrain: Terrain[][], animals: Array<{x:number,y:number, animal:Animal}>, structures: Array<{x:number,y:number, type:StructureType, color:Color}> }} TileDef */

// Default tiles with animals (from your last message)
const DEFAULT_TILES = {
  "1": {"terrain":[["water","water","water","water","forest","forest"],["swamp","swamp","water","desert","forest","forest"],["swamp","swamp","desert","desert","desert","forest"]],"animals":[{"x":3,"y":2,"animal":"bear"},{"x":4,"y":2,"animal":"bear"}],"structures":[]},
  "2": {"terrain":[["swamp","forest","forest","forest","forest","forest"],["swamp","swamp","forest","desert","desert","desert"],["swamp","mountain","mountain","mountain","mountain","desert"]],"animals":[{"x":0,"y":0,"animal":"cougar"},{"x":1,"y":0,"animal":"cougar"},{"x":2,"y":0,"animal":"cougar"}],"structures":[]},
  "3": {"terrain":[["swamp","swamp","forest","forest","forest","water"],["swamp","swamp","forest","mountain","water","water"],["mountain","mountain","mountain","mountain","water","water"]],"animals":[{"x":0,"y":1,"animal":"cougar"},{"x":1,"y":1,"animal":"cougar"},{"x":0,"y":2,"animal":"cougar"}],"structures":[]},
  "4": {"terrain":[["desert","desert","mountain","mountain","mountain","mountain"],["desert","desert","mountain","water","water","water"],["desert","desert","desert","forest","forest","forest"]],"animals":[{"x":5,"y":1,"animal":"cougar"},{"x":5,"y":2,"animal":"cougar"}],"structures":[]},
  "5": {"terrain":[["swamp","swamp","swamp","mountain","mountain","mountain"],["swamp","desert","desert","water","mountain","mountain"],["desert","desert","water","water","water","water"]],"animals":[{"x":5,"y":1,"animal":"bear"},{"x":4,"y":2,"animal":"bear"},{"x":5,"y":2,"animal":"bear"}],"structures":[]},
  "6": {"terrain":[["desert","desert","swamp","swamp","swamp","forest"],["mountain","mountain","swamp","swamp","forest","forest"],["mountain","water","water","water","water","forest"]],"animals":[{"x":0,"y":0,"animal":"bear"},{"x":0,"y":1,"animal":"bear"}],"structures":[]}
};
/** @type {Record<number, TileDef>} */
let TILES = structuredClone(DEFAULT_TILES);
let lastArrangement = null; // Array<{id:number, flipped:boolean, col:number, row:number}>
let showTileLabels = true;

// ===== Geometry: FLAT-TOP, odd-q offset =====
const svg = document.getElementById('hexsvg');
svg.addEventListener('mousedown', (e)=>{ if(e.shiftKey) e.preventDefault(); });
const svgNS = 'http://www.w3.org/2000/svg';
let HEX_SIZE = 26;
function hexToPoint(q,r){
	const x = 1.5 * HEX_SIZE * q;
	const y = Math.sqrt(3) * HEX_SIZE * (r + ((q & 1) ? 0.5 : 0));
	return {x,y};
}
function polygonPoints(cx,cy,size){
	const pts=[];
	for(let i=0;i<6;i++){
		const ang = Math.PI/180 * (60*i);
		pts.push([cx + size*Math.cos(ang), cy + size*Math.sin(ang)]);
	}
	return pts.map(([x,y])=>x.toFixed(2)+","+y.toFixed(2)).join(' ');
}
function regularPolygonPoints(cx, cy, radius, sides, rotationDeg=0){
	const pts=[]; const rot = Math.PI/180 * rotationDeg;
	for(let i=0;i<sides;i++){
		const ang = rot + i * (2*Math.PI/sides);
		pts.push([cx + radius*Math.cos(ang), cy + radius*Math.sin(ang)]);
	}
	return pts.map(([x,y])=>x.toFixed(2)+","+y.toFixed(2)).join(' ');
}

function draw(perRuleOverlays, uniqueKey){
	svg.innerHTML='';
	// tight viewBox
	const Rx = HEX_SIZE, Ry = Math.sqrt(3)*HEX_SIZE/2;
	let minX=Infinity, minY=Infinity, maxX=-Infinity, maxY=-Infinity;
	const centers=new Map();
	forEachCell(c=>{ const p=hexToPoint(c.q,c.r); centers.set(key(c.q,c.r),p);
		minX=Math.min(minX,p.x-Rx); maxX=Math.max(maxX,p.x+Rx);
		minY=Math.min(minY,p.y-Ry); maxY=Math.max(maxY,p.y+Ry); });
	const pad=HEX_SIZE*1.2; svg.setAttribute('viewBox', `${minX-pad} ${minY-pad} ${maxX-minX+pad*2} ${maxY-minY+pad*2}`);

	forEachCell(c=>{
		const {x,y}=centers.get(key(c.q,c.r));
		const g=document.createElementNS(svgNS,'g'); g.setAttribute('transform',`translate(${x},${y})`); g.dataset.q=String(c.q); g.dataset.r=String(c.r);
		// base
		const poly=document.createElementNS(svgNS,'polygon'); poly.setAttribute('points', polygonPoints(0,0,HEX_SIZE)); poly.setAttribute('fill',TERRAIN_COLORS[c.terrain]); poly.setAttribute('stroke','#0b1220'); poly.setAttribute('stroke-width','1'); g.appendChild(poly);
		// animals
		if(c.animals.size){ const t=document.createElementNS(svgNS,'text'); t.setAttribute('x','0'); t.setAttribute('y','-6'); t.setAttribute('text-anchor','middle'); t.setAttribute('font-size','16'); t.setAttribute('font-weight','700'); t.textContent=[...c.animals].map(a=>ANIMAL_GLYPH[a]).join(''); g.appendChild(t); }
		// structures
		if(c.structures.length){
			const sG=document.createElementNS(svgNS,'g');
			sG.setAttribute('transform','translate(0,8)');
			c.structures.slice(0,3).forEach((s,i)=>{
				const dx=-12 + i*12;
				if(s.type==='standing_stone'){
					const p=document.createElementNS(svgNS,'polygon');
					p.setAttribute('points', regularPolygonPoints(dx,0,5.5,8,22.5));
					p.setAttribute('fill', STRUCT_COLORS[s.color]);
					p.setAttribute('stroke', '#0b1220'); p.setAttribute('stroke-width','1');
					sG.appendChild(p);
				} else {
					const p=document.createElementNS(svgNS,'polygon');
					p.setAttribute('points', regularPolygonPoints(dx,0,6,3,-90));
					p.setAttribute('fill', STRUCT_COLORS[s.color]);
					p.setAttribute('stroke', '#0b1220'); p.setAttribute('stroke-width','1');
					sG.appendChild(p);
				}
			});
			g.appendChild(sG);
		}
		// per-rule outlines (use player colors if provided)
		if(Array.isArray(perRuleOverlays)){
			perRuleOverlays.forEach((ov,i)=>{ if(ov.set.has(key(c.q,c.r))){ const inset=3+i*3; const hl=document.createElementNS(svgNS,'polygon'); hl.setAttribute('points', polygonPoints(0,0,Math.max(HEX_SIZE-inset,6))); hl.setAttribute('fill','none'); hl.setAttribute('stroke', ov.color || RULE_COLORS[i%RULE_COLORS.length]); hl.setAttribute('stroke-width','3'); g.appendChild(hl);} });
		}
		// unique intersection
		if(uniqueKey && uniqueKey===key(c.q,c.r)){
			const ring=document.createElementNS(svgNS,'circle'); ring.setAttribute('cx','0'); ring.setAttribute('cy','0'); ring.setAttribute('r',String(HEX_SIZE-6)); ring.setAttribute('fill','none'); ring.setAttribute('stroke','#fde68a'); ring.setAttribute('stroke-width','5'); g.appendChild(ring);
			const dot=document.createElementNS(svgNS,'circle'); dot.setAttribute('cx','0'); dot.setAttribute('cy','0'); dot.setAttribute('r','3'); dot.setAttribute('fill','#ffffff'); g.appendChild(dot);
		}
		g.addEventListener('click', onHexClick); svg.appendChild(g);
	});

	// tile number labels
	if(showTileLabels && Array.isArray(lastArrangement)){
		lastArrangement.forEach(arr=>{
			const q0 = arr.col * TILE_W, r0 = arr.row * TILE_H;
			const corner = arr.flipped ? hexToPoint(q0 + TILE_W - 1, r0 + TILE_H - 1) : hexToPoint(q0, r0);
			const tx = arr.flipped ? corner.x + HEX_SIZE * 0.7 : corner.x - HEX_SIZE * 0.7;
			const ty = arr.flipped ? corner.y + HEX_SIZE * 0.7 : corner.y - HEX_SIZE * 0.7;
			const t = document.createElementNS(svgNS,'text');
			t.setAttribute('x', String(tx)); t.setAttribute('y', String(ty));
			t.setAttribute('text-anchor', arr.flipped ? 'end' : 'start');
			t.setAttribute('dominant-baseline', arr.flipped ? 'ideographic' : 'hanging');
			t.setAttribute('font-size','18'); t.setAttribute('font-weight','800');
			t.setAttribute('fill','#f8fafc'); t.setAttribute('stroke','#000'); t.setAttribute('stroke-width','3'); t.style.paintOrder='stroke';
			t.textContent = String(arr.id);
			svg.appendChild(t);
		});
	}
}

// ===== Painting =====
let currentTerrain = /** @type {Terrain} */ ('desert');
let currentMarker = /** @type {{ kind:'animal'|'structure'|null, value?:any }} */ ({ kind:null });
function onHexClick(e){
	e.preventDefault(); e.stopPropagation();
	const g=e.currentTarget; const q=+g.dataset.q; const r=+g.dataset.r; const c=cellAt(q,r);
	if(e.altKey){ c.animals.clear(); c.structures=[]; draw(latestPerRule, latestUniqueKey); updateRuleCounts(); return; }
	if(e.shiftKey){
		if(currentMarker.kind==='animal'){
			if(c.animals.has(currentMarker.value)) c.animals.delete(currentMarker.value); else c.animals.add(currentMarker.value);
		}
		else if(currentMarker.kind==='structure'){
			const {type,color}=currentMarker.value||{};
			if(type && color){
				const idx=c.structures.findIndex(s=>s.type===type && s.color===color);
				if(idx>=0) c.structures.splice(idx,1); else c.structures.push({type,color});
			}
		}
	}
	else { c.terrain=currentTerrain; }
	draw(latestPerRule, latestUniqueKey); updateRuleCounts();
}

// ===== Palettes =====
const terrainPalette=document.getElementById('terrainPalette');
const markerPalette=document.getElementById('markerPalette');
function buildPalettes(){
	terrainPalette.innerHTML=''; TERRAIN.forEach(t=>{ const li=document.createElement('li'); li.style.cursor='pointer'; li.innerHTML=`<span class='sw' style='background:${TERRAIN_COLORS[t]}'></span>${t}`; li.addEventListener('click',()=>{ currentTerrain=t; highlightSelected(terrainPalette, li); }); terrainPalette.appendChild(li); }); highlightSelected(terrainPalette, terrainPalette.firstElementChild);
	markerPalette.innerHTML=''; const none=document.createElement('li'); none.textContent='‚Äî none ‚Äî'; none.style.cursor='pointer'; none.addEventListener('click',()=>{ currentMarker={kind:null}; highlightSelected(markerPalette, none); }); markerPalette.appendChild(none);
	ANIMALS.forEach(a=>{ const li=document.createElement('li'); li.style.cursor='pointer'; li.textContent=`${a} ${ANIMAL_GLYPH[a]}`; li.addEventListener('click',()=>{ currentMarker={kind:'animal', value:a}; highlightSelected(markerPalette, li); }); markerPalette.appendChild(li); });
	STRUCT_TYPES.forEach(st=>{ COLORS.forEach(col=>{ const li=document.createElement('li'); li.style.cursor='pointer'; li.innerHTML=`<span class='colorChip' style='background:${STRUCT_COLORS[col]}'></span> ${col} ${st.replace('_',' ')}`; li.addEventListener('click',()=>{ currentMarker={kind:'structure', value:{type:st,color:col}}; highlightSelected(markerPalette, li); }); markerPalette.appendChild(li); }); });
	highlightSelected(markerPalette, none);
}
function highlightSelected(list, el){ [...list.children].forEach(c=>c.style.outline=''); if(el) el.style.outline='2px solid #22d3ee'; }

// ===== Tile helpers =====
function blankBoard(){
	Board.cells.clear();
	for(let r=0;r<Board.height;r++){
		for(let q=0;q<Board.width;q++){
			const c=cellAt(q,r); c.terrain='water'; c.animals.clear(); c.structures=[];
		}
	}
}
function mapXY(x,y, flipped){ return flipped ? {x:TILE_W-1-x, y:TILE_H-1-y} : {x,y}; }
function stampTile(tileId, flipped, col, row){
	const def = TILES[Number(tileId)]; if(!def) return;
	const q0 = col * TILE_W, r0 = row * TILE_H;
	for(let y=0;y<TILE_H;y++){
		for(let x=0;x<TILE_W;x++){
			const m = mapXY(x,y, flipped);
			const c = cellAt(q0+x, r0+y);
			c.terrain = def.terrain[m.y][m.x];
			c.animals.clear(); c.structures=[];
		}
	}
	(def.animals||[]).forEach(a=>{ const m=mapXY(a.x,a.y,flipped); cellAt(q0+m.x, r0+m.y).animals.add(a.animal); });
	(def.structures||[]).forEach(s=>{ const m=mapXY(s.x,s.y,flipped); cellAt(q0+m.x, r0+m.y).structures.push({type:s.type, color:s.color}); });
}
function parseArrangement(str){
	const nums = (str.match(/[+-]?[0-9]+/g)||[]).map(n=>parseInt(n,10));
	if(nums.length!==6) throw new Error('Provide six signed integers 1..6');
	const abs = nums.map(n=>Math.abs(n));
	if(abs.some(n=>n<1||n>6)) throw new Error('Tile ids must be 1..6');
	const uniq = new Set(abs); if(uniq.size!==6) throw new Error('Tile ids must not repeat');
	return nums.map((n,i)=>({ id:Math.abs(n), flipped:n<0, col:i%2, row:Math.floor(i/2) }));
}
function applyArrangementString(str, redraw=true){
	try{
		const arr = parseArrangement(str);
		lastArrangement = arr;
		blankBoard();
		arr.forEach(a=> stampTile(a.id, a.flipped, a.col, a.row));
		if(redraw){ draw(latestPerRule, latestUniqueKey); updateRuleCounts(); }
	}catch(e){ alert(e.message); }
}

// ===== Import/Export (board) =====
const exportBtn=document.getElementById('exportBoard');
const importBtn=document.getElementById('importBoard');
const boardJSON=document.getElementById('boardJSON');
exportBtn.addEventListener('click',()=>{ const data={ width:Board.width, height:Board.height, cells:[...Board.cells.values()].map(c=>({ q:c.q,r:c.r, terrain:c.terrain, animals:[...c.animals], structures:c.structures }))}; boardJSON.value=JSON.stringify(data,null,2); });
importBtn.addEventListener('click',()=>{ try{ const data=JSON.parse(boardJSON.value); Board.width=12; Board.height=9; Board.cells.clear(); for(const raw of data.cells||[]){ const c=cellAt(raw.q, raw.r); c.terrain=raw.terrain; c.animals=new Set(raw.animals||[]); c.structures=raw.structures||[]; } draw(latestPerRule, latestUniqueKey); updateRuleCounts();}catch(e){ alert('Invalid JSON'); }});

// (Tiles are fixed to the standard 6; no capture/export/import UI)
// ===== Tile UI wires =====
const arrangementStr = document.getElementById('arrangementStr');
const applyArrangementBtn = document.getElementById('applyArrangement');
const toggleTileLabelsBtn = document.getElementById('toggleTileLabels');
applyArrangementBtn.addEventListener('click', ()=> applyArrangementString(arrangementStr.value||'1 2 3 4 5 6'));
arrangementStr.addEventListener('keydown', (e)=>{ if(e.key==='Enter'){ e.preventDefault(); applyArrangementString(arrangementStr.value||'1 2 3 4 5 6'); }});

toggleTileLabelsBtn.addEventListener('click', ()=>{ showTileLabels=!showTileLabels; draw(latestPerRule, latestUniqueKey); updateRuleCounts(); });

// ===== Legend =====
function buildLegend(){ const wrap=document.getElementById('legend'); wrap.innerHTML=''; TERRAIN.forEach(t=>{ const d=document.createElement('div'); d.className='swatch'; d.innerHTML=`<span class='sw' style='background:${TERRAIN_COLORS[t]}'></span>${t}`; wrap.appendChild(d); }); ANIMALS.forEach(a=>{ const d=document.createElement('div'); d.className='swatch'; d.textContent=`${a} ${ANIMAL_GLYPH[a]}`; wrap.appendChild(d); }); STRUCT_TYPES.forEach(st=>{ COLORS.forEach(col=>{ const d=document.createElement('div'); d.className='swatch'; d.innerHTML=`<span class='colorChip' style='background:${STRUCT_COLORS[col]}'></span>${col} ${st.replace('_',' ')}`; wrap.appendChild(d); }); }); }

// ===== Rules =====
/** @typedef {{ id:string, label:string, negated:boolean, within:0|1|2|3, targets:Array<{kind:'terrain',terrain:Terrain[]}|{kind:'animal',animal:Animal[]}|{kind:'structure',type:StructureType[],colors:Color[] }>, players:number[] }} Rule */
const DEFAULT_RULES=(()=>{ const rules=[]; let id=1; const add=(label,negated,within,targets,players)=>rules.push({id:String(id++),label,negated,within,targets,players});
	add('on desert',false,0,[{kind:'terrain',terrain:['desert']}],[3,4,5]);
	add('on swamp',false,0,[{kind:'terrain',terrain:['swamp']}],[3,4,5]);
	add('on mountain',false,0,[{kind:'terrain',terrain:['mountain']}],[3,4,5]);
	add('on forest',false,0,[{kind:'terrain',terrain:['forest']}],[3,4,5]);
	add('on water',false,0,[{kind:'terrain',terrain:['water']}],[3,4,5]);
	add('not on desert or mountain',true,0,[{kind:'terrain',terrain:['desert','mountain']}],[3,4,5]);
	add('not on swamp or forest',true,0,[{kind:'terrain',terrain:['swamp','forest']}],[3,4,5]);
	add('not on water',true,0,[{kind:'terrain',terrain:['water']}],[3,4,5]);
	add('within 1 of desert or swamp',false,1,[{kind:'terrain',terrain:['desert','swamp']}],[3,4,5]);
	add('within 1 of mountain or forest',false,1,[{kind:'terrain',terrain:['mountain','forest']}],[3,4,5]);
	add('within 2 of water',false,2,[{kind:'terrain',terrain:['water']}],[3,4,5]);
	add('not within 1 of water',true,1,[{kind:'terrain',terrain:['water']}],[3,4,5]);
	add('within 1 of a bear territory',false,1,[{kind:'animal',animal:['bear']}],[3,4,5]);
	add('within 1 of a cougar territory',false,1,[{kind:'animal',animal:['cougar']}],[3,4,5]);
	add('within 2 of a bear or cougar territory',false,2,[{kind:'animal',animal:['bear','cougar']}],[3,4,5]);
	add('not within 1 of any animal territory',true,1,[{kind:'animal',animal:['bear','cougar']}],[3,4,5]);
	add('within 1 of a standing stone',false,1,[{kind:'structure',type:['standing_stone'],colors:['black','blue','green','white']}],[3,4,5]);
	add('within 1 of an abandoned shack',false,1,[{kind:'structure',type:['abandoned_shack'],colors:['black','blue','green','white']}],[3,4,5]);
	add('within 2 of any structure',false,2,[{kind:'structure',type:['standing_stone','abandoned_shack'],colors:['black','blue','green','white']}],[3,4,5]);
	add('not within 1 of any structure',true,1,[{kind:'structure',type:['standing_stone','abandoned_shack'],colors:['black','blue','green','white']}],[3,4,5]);
	add('within 1 of a black structure',false,1,[{kind:'structure',type:['standing_stone','abandoned_shack'],colors:['black']}],[3,4,5]);
	add('within 1 of a blue structure',false,1,[{kind:'structure',type:['standing_stone','abandoned_shack'],colors:['blue']}],[3,4,5]);
	add('within 1 of a green structure',false,1,[{kind:'structure',type:['standing_stone','abandoned_shack'],colors:['green']}],[3,4,5]);
	add('within 1 of a white structure',false,1,[{kind:'structure',type:['standing_stone','abandoned_shack'],colors:['white']}],[3,4,5]);
	add('on desert or forest',false,0,[{kind:'terrain',terrain:['desert','forest']}],[3,4,5]);
	add('on swamp or mountain',false,0,[{kind:'terrain',terrain:['swamp','mountain']}],[3,4,5]);
	add('not on desert or forest',true,0,[{kind:'terrain',terrain:['desert','forest']}],[3,4,5]);
	add('not on swamp or mountain',true,0,[{kind:'terrain',terrain:['swamp','mountain']}],[3,4,5]);
	add('within 3 of water',false,3,[{kind:'terrain',terrain:['water']}],[3,4,5]);
	add('not within 3 of water',true,3,[{kind:'terrain',terrain:['water']}],[3,4,5]);
	add('within 3 of any structure',false,3,[{kind:'structure',type:['standing_stone','abandoned_shack'],colors:['black','blue','green','white']}],[3,4,5]);
	add('within 3 of any animal territory',false,3,[{kind:'animal',animal:['bear','cougar']}],[3,4,5]);
	add('not on mountain',true,0,[{kind:'terrain',terrain:['mountain']}],[3,4,5]);
	add('not on swamp',true,0,[{kind:'terrain',terrain:['swamp']}],[3,4,5]);
	add('not on forest',true,0,[{kind:'terrain',terrain:['forest']}],[3,4,5]);
	add('within 1 of a black standing stone',false,1,[{kind:'structure',type:['standing_stone'],colors:['black']}],[3,4,5]);
	add('within 1 of a green abandoned shack',false,1,[{kind:'structure',type:['abandoned_shack'],colors:['green']}],[3,4,5]);
	add('within 2 of a blue standing stone',false,2,[{kind:'structure',type:['standing_stone'],colors:['blue']}],[3,4,5]);
	add('within 2 of a white abandoned shack',false,2,[{kind:'structure',type:['abandoned_shack'],colors:['white']}],[3,4,5]);
	add('within 1 of desert or a standing stone',false,1,[{kind:'terrain',terrain:['desert']},{kind:'structure',type:['standing_stone'],colors:['black','blue','green','white']}],[3,4,5]);
	add('within 2 of swamp or a cougar territory',false,2,[{kind:'terrain',terrain:['swamp']},{kind:'animal',animal:['cougar']}],[3,4,5]);
	add('within 2 of mountain',false,2,[{kind:'terrain',terrain:['mountain']}],[3,4]);
	add('within 2 of forest',false,2,[{kind:'terrain',terrain:['forest']}],[4,5]);
	add('not within 1 of a black structure',true,1,[{kind:'structure',type:['standing_stone','abandoned_shack'],colors:['black']}],[5]);
	add('not within 1 of a bear territory',true,1,[{kind:'animal',animal:['bear']}],[3]);
	add('within 1 of water',false,1,[{kind:'terrain',terrain:['water']}],[3,4,5]);
	add('within 2 of desert or forest',false,2,[{kind:'terrain',terrain:['desert','forest']}],[3,4,5]);
	add('within 2 of swamp or mountain',false,2,[{kind:'terrain',terrain:['swamp','mountain']}],[3,4,5]);
	add('not within 2 of any animal territory',true,2,[{kind:'animal',animal:['bear','cougar']}],[3,4,5]);
	add('not within 2 of any structure',true,2,[{kind:'structure',type:['standing_stone','abandoned_shack'],colors:['black','blue','green','white']}],[3,4,5]);
	add('on desert or swamp',false,0,[{kind:'terrain',terrain:['desert','swamp']}],[3,4,5]);
	add('on forest or mountain',false,0,[{kind:'terrain',terrain:['forest','mountain']}],[3,4,5]);
	return rules.slice(0,48);
})();
let RULES=structuredClone(DEFAULT_RULES);

const rulesJSON=document.getElementById('rulesJSON'); function refreshRulesJSON(){ rulesJSON.value=JSON.stringify(RULES,null,2); }
const ruleList=document.getElementById('ruleList'); const playersSel=document.getElementById('players');

function rebuildRuleList(){
	ruleList.innerHTML='';
	const p=+playersSel.value; const subset=RULES.filter(r=>r.players.includes(p));
	subset.forEach((r,i)=>{
		const row=document.createElement('div'); row.className='ruleItem'; row.dataset.id=r.id;
		const label=document.createElement('div'); label.textContent=r.label; label.style.cursor='default';
		const count=document.createElement('div'); count.id=`rc_${r.id}`; count.className='small'; count.textContent='';
		row.appendChild(label); row.appendChild(count);ruleList.appendChild(row);
	});
}

// counts for all visible rules (auto)
function updateRuleCounts(){
	const p=+playersSel.value; const subset=RULES.filter(r=>r.players.includes(p));
	subset.forEach(r=>{ const s=evalRule(r); const el=document.getElementById(`rc_${r.id}`); if(el) el.textContent=String(s.size); });
}

// ===== Players & assignments =====
function visibleRules(){ const p=+playersSel.value; return RULES.filter(r=>r.players.includes(p)); }
function rebuildAssignmentsUI(){
	const host=document.getElementById('assignments'); if(!host) return; host.innerHTML='';
	const p=+playersSel.value;
	const defaultColors = DEFAULT_PLAYER_COLORS_BY_COUNT[p] || PLAYER_COLOR_ORDER.slice(0,p);
	if(PLAYER_ASSIGNMENTS.length!==p){
		PLAYER_ASSIGNMENTS = Array.from({length:p}, (_,i)=>({ color: defaultColors[i]||PLAYER_COLOR_ORDER[i], ruleId: (PLAYER_ASSIGNMENTS[i]&&PLAYER_ASSIGNMENTS[i].ruleId)||null }));
	} else {
		PLAYER_ASSIGNMENTS.forEach((a,i)=>{ if(!a||!a.color){ PLAYER_ASSIGNMENTS[i]={ color: defaultColors[i]||PLAYER_COLOR_ORDER[i], ruleId: a?a.ruleId:null }; } });
	}
	const rules = visibleRules();
	PLAYER_ASSIGNMENTS.forEach((a,idx)=>{
		const row=document.createElement('div'); row.className='row';
		const label=document.createElement('label'); label.textContent=`Player ${idx+1}`; label.style.minWidth='70px';
		const chip=document.createElement('span'); chip.className='colorChip'; chip.style.background=PLAYER_COLORS[a.color]; chip.style.marginRight='6px';
		const colorSel=document.createElement('select');
		PLAYER_COLOR_ORDER.forEach(c=>{ const opt=document.createElement('option'); opt.value=c; opt.textContent=c; opt.selected=(a.color===c); colorSel.appendChild(opt); });
		colorSel.addEventListener('change', ()=>{ a.color=colorSel.value; chip.style.background=PLAYER_COLORS[a.color]; });
		const ruleSel=document.createElement('select');
		const none=document.createElement('option'); none.value=''; none.textContent='‚Äî none ‚Äî'; ruleSel.appendChild(none);
		rules.forEach(r=>{ const opt=document.createElement('option'); opt.value=r.id; opt.textContent=r.label; opt.selected=(a.ruleId===r.id); ruleSel.appendChild(opt); });
		ruleSel.addEventListener('change', ()=>{ a.ruleId = ruleSel.value||null; });
		row.appendChild(label); row.appendChild(chip); row.appendChild(colorSel); row.appendChild(ruleSel);
		host.appendChild(row);
	});
}

// ===== Evaluate =====
function evalRule(rule){
	const good=new Set();
	forEachCell(c=>{
		let hit=false;
		for(const t of rule.targets){
			if(t.kind==='terrain'){
				if(rule.within===0){ if(t.terrain.includes(c.terrain)) hit=true; }
				else { forEachCell(c2=>{ if(!hit && t.terrain.includes(c2.terrain) && hexDist(c,c2)<=rule.within) hit=true; }); }
			} else if(t.kind==='animal'){
				if(rule.within>0){ forEachCell(c2=>{ if(!hit){ const has=t.animal.some(a=>c2.animals.has(a)); if(has && hexDist(c,c2)<=rule.within) hit=true; } }); }
			} else if(t.kind==='structure'){
				if(rule.within>0){ forEachCell(c2=>{ if(!hit){ const any=c2.structures.some(s=>t.type.includes(s.type)&&t.colors.includes(s.color)); if(any && hexDist(c,c2)<=rule.within) hit=true; } }); }
			}
			if(hit) break;
		}
		const ok=rule.negated?!hit:hit;
		if(ok) good.add(key(c.q,c.r));
	});
	return good;
}
let latestPerRule=null, latestUniqueKey=null;
const evaluateBtn=document.getElementById('evaluate');
const clearHighlightsBtn=document.getElementById('clearHighlights');
const resultSummary=document.getElementById('resultSummary');

evaluateBtn.addEventListener('click',()=>{
	const p=+playersSel.value; const subset=RULES.filter(r=>r.players.includes(p));
	const byId=new Map(subset.map(r=>[r.id,r]));
	const act = PLAYER_ASSIGNMENTS.map(a=>a.ruleId).filter(Boolean).map(id=>byId.get(id)).filter(Boolean);
	if(act.length===0){ latestPerRule=null; latestUniqueKey=null; draw(); updateRuleCounts(); resultSummary.textContent='No assigned rules.'; return; }
	const per = act.map((r,i)=>[r, evalRule(r), i]);
	per.forEach(([r,s])=>{ const el=document.getElementById(`rc_${r.id}`); if(el) el.textContent=`${s.size}`; });
	const overlays = per.map(([r,s,i])=>({id:r.id,set:s,color: PLAYER_COLORS[PLAYER_ASSIGNMENTS[i].color] }));
	let acc=null; per.forEach(([_,s])=>{ acc = acc? intersect(acc,s): s; });
	const uniqKey=acc.size===1?[...acc][0]:null;
	latestPerRule=overlays; latestUniqueKey=uniqKey; draw(overlays,uniqKey); updateRuleCounts();
	const lines=[`Assigned rules: ${act.length}`, `Intersection: ${acc.size}`];
	per.slice(0,5).forEach(([r,s],i)=>lines.push(`#P${i+1} ${r.label} ‚Üí ${s.size}`));
	resultSummary.textContent=lines.join('  |  ');
});
function intersect(a,b){ const out=new Set(); for(const v of a) if(b.has(v)) out.add(v); return out; }
clearHighlightsBtn.addEventListener('click',()=>{ latestPerRule=null; latestUniqueKey=null; draw(); updateRuleCounts(); resultSummary.textContent='‚Äî'; });
playersSel.addEventListener('change', ()=>{ rebuildRuleList(); rebuildAssignmentsUI(); updateRuleCounts(); });

// ===== Bootstrap =====
buildPalettes(); buildLegend();
applyArrangementString(document.getElementById('arrangementStr').value, false);
draw();
rebuildRuleList();
rebuildAssignmentsUI();
updateRuleCounts();
refreshRulesJSON();

</script>
</body>
</html>
