<!doctype html>
<html lang="en">
<head>
	<meta charset="utf-8" />
	<meta name="viewport" content="width=device-width, initial-scale=1" />
	<title>Cryptid Board Analyzer (Lightweight)</title>
	<style>
		:root { --pad: 10px; --bg: #0f172a; --panel: #111827; --muted: #94a3b8; --text: #e5e7eb; }
		html, body { height: 100%; }
		body {
			margin: 0; font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
			background: var(--bg); color: var(--text); display: grid; grid-template-columns: 320px 1fr 420px;
			grid-template-rows: auto 1fr; grid-template-areas:
				"header header header"
				"left canvas right";
			gap: 10px; padding: var(--pad);
		}
		h1 { font-size: 18px; margin: 0; letter-spacing: .2px; }
		#header { grid-area: header; display:flex; align-items:center; gap:12px; background:var(--panel); border-radius:12px; padding:10px 14px; }
		.badge { font-size: 12px; color: var(--bg); background: #a7f3d0; border-radius: 999px; padding: 2px 8px; }
		.panel { background: var(--panel); border-radius: 12px; padding: 10px; }
		#left { grid-area: left; display: grid; gap: 10px; align-content: start; }
		#right { grid-area: right; display: grid; gap: 10px; align-content: start; }
		#canvasWrap { grid-area: canvas; position: relative; background: #0b1220; border-radius: 12px; overflow: hidden; }
		label { font-size: 12px; color: var(--muted); }
		select, button, input[type="number"], textarea, input[type="text"] { width: 100%; background: #0b1220; color: var(--text); border: 1px solid #243041; border-radius: 8px; padding: 8px; font: inherit; }
		button { cursor: pointer; }
		button.inline { width: auto; padding: 6px 10px; border-radius: 8px; }
		.group { display: grid; gap: 6px; }
		.row { display:flex; gap:8px; align-items:center; flex-wrap: wrap; }
		.small { font-size: 12px; color: var(--muted); }
		.kbd { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; background:#0b1220; border:1px solid #223048; padding:2px 6px; border-radius:6px; }
		legend { font-size: 12px; color: var(--muted); margin-bottom: 6px; }
		.ruleList { display:grid; gap:6px; max-height: 42vh; overflow:auto; border:1px solid #223048; border-radius:8px; padding:8px; }
		.ruleItem { display:grid; grid-template-columns: 1fr 42px; gap:6px; align-items:center; }
		#hexsvg { width:100%; height:100%; display:block; }
		#canvasWrap, #hexsvg, #hexsvg * { -webkit-user-select: none; user-select: none; }
		#legend { display:grid; grid-template-columns: repeat(5, minmax(0,1fr)); gap:6px; }
		.swatch { display:flex; gap:6px; align-items:center; background:#0b1220; border:1px solid #243041; border-radius:8px; padding:6px; justify-content:center; }
		.sw { width:14px; height:14px; border-radius:3px; border:1px solid #0007; }
		ul.flat { list-style:none; padding:0; margin:0; display:flex; gap:8px; flex-wrap:wrap; }
		ul.flat li { padding:4px 8px; border:1px solid #223048; border-radius:8px; background:#0b1220; font-size:12px; }
		textarea.code { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace; height: 160px; }
		hr { border:0; border-top:1px solid #223048; margin:8px 0; }
		.colorChip { width:14px; height:14px; border-radius:999px; display:inline-block; vertical-align:middle; border:1px solid #0007; }
	</style>
</head>
<body>
	<header id="header" class="panel">
		<h1>Cryptid Analyzer</h1>
		<span class="badge">flat-top hex ¬∑ 12√ó9</span>
		<div class="small">
			Click = paint terrain ¬∑ <span class="kbd">Shift</span>+Click = toggle marker (animal/structure) ¬∑
			<span class="kbd">Alt</span>+Click = erase ¬∑ Evaluate draws outlines for each player's assigned rule; the single cell satisfying all assigned rules is highlighted.
		</div>
	</header>

	<section id="left">
		<div class="panel group">
			<label for="players">Players</label>
			<select id="players">
				<option value="3">3 players</option>
				<option value="4" selected>4 players</option>
				<option value="5">5 players</option>
			</select>
			<div class="row">
				<button id="evaluate" class="inline">Evaluate</button>
				<button id="clearHighlights" class="inline">Clear</button>
			</div>
			<div class="row">
				<input type="checkbox" id="showHabitat">
				<label for="showHabitat" style="margin-left: 6px; font-size: 14px;">Show Habitat</label>
			</div>
			<div class="small" id="resultSummary">‚Äî</div>
		</div>

		<div class="panel group">
			<legend>Board</legend>
			<legend>Paint</legend>
			<ul class="flat" id="terrainPalette"></ul>
			<legend>Markers</legend>
			<ul class="flat" id="markerPalette"></ul>
		</div>

		<div class="panel group">
			<legend>Tile arrangement (2√ó3)</legend>
			<input id="arrangementStr" class="code" placeholder="e.g., 6 3 1 5 4 2" value="-4 -2 -5 1 -3 6">
			<div class="row">
				<button id="applyArrangement" class="inline">Apply</button>
				<button id="toggleTileLabels" class="inline">Toggle labels</button>
			</div>
			
		</div>

		<div class="panel group">
			<legend>Import / Export Game</legend>
			<div class="row">
				<button id="exportGame" class="inline">Export Game JSON</button>
				<button id="importGame" class="inline">Import</button>
			</div>
			<textarea id="gameJSON" class="code" placeholder="Game JSON will appear here..."></textarea>
		</div>
	</section>

	<main id="canvasWrap">
		<svg id="hexsvg" viewBox="0 0 1000 1000" role="img" aria-label="Cryptid board"></svg>
	</main>

	<aside id="right">
		<div class="panel group">
			<legend>Rules (filtered by players)</legend>
			<div class="ruleList" id="ruleList"></div>
			<div class="small">Counts update automatically.</div>
		</div>

		<div class="panel group">
			<legend>Players & clues</legend>
			<div id="assignments"></div>
		</div>
	</aside>

<script>
// ===== Core data =====
const TERRAIN = /** @type {const} */ (['desert','swamp','mountain','forest','water']);
const ANIMALS = /** @type {const} */ (['bear','cougar']);
const STRUCT_TYPES = /** @type {const} */ (['standing_stone','abandoned_shack']);
const COLORS = /** @type {const} */ (['black','blue','green','white']);

const TERRAIN_COLORS = { desert:'#eab308', swamp:'#7c3aed', mountain:'#9ca3af', forest:'#16a34a', water:'#0284c7' };
const STRUCT_COLORS = { black:'#111827', blue:'#3b82f6', green:'#22c55e', white:'#e5e7eb' };
const RULE_COLORS = ['#f97316','#22d3ee','#a78bfa','#34d399','#f43f5e','#eab308','#06b6d4','#84cc16'];

const PLAYER_COLORS = { blue:'#3b82f6', red:'#ef4444', green:'#22c55e', purple:'#a78bfa', orange:'#f97316' };
const PLAYER_COLOR_ORDER = ['blue','red','green','purple','orange'];
const DEFAULT_PLAYER_COLORS_BY_COUNT = {3:['blue','red','green'],4:['blue','red','green','purple'],5:['blue','red','green','purple','orange']};
let PLAYER_ASSIGNMENTS = []; // [{color:'blue'|'red'|'green'|'purple'|'orange', ruleId:string|null, clueNumber:number|null}]

// Game configurations for different player counts
let GAME_CONFIGURATIONS = {
	3: [],  // Array of {color, clueNumber}
	4: [],  // Array of {color, clueNumber} 
	5: []   // Array of {color, clueNumber}
};

// Default game setup
const DEFAULT_GAME = {
	tileArrangement: "-4 -2 -5 1 -3 6",
	structures: [
		// Standing stones
		{type: 'standing_stone', color: 'white', q: 4, r: 0},
		{type: 'standing_stone', color: 'green', q: 1, r: 4},
		{type: 'standing_stone', color: 'black', q: 2, r: 4},
		{type: 'standing_stone', color: 'blue', q: 4, r: 6},
		// Abandoned shacks  
		{type: 'abandoned_shack', color: 'green', q: 4, r: 1},
		{type: 'abandoned_shack', color: 'blue', q: 4, r: 2},
		{type: 'abandoned_shack', color: 'white', q: 2, r: 3},
		{type: 'abandoned_shack', color: 'black', q: 7, r: 4}
	],
	playerConfigs: {
		3: [{color: 'green', clueNumber: 68}, {color: 'orange', clueNumber: 5}, {color: 'purple', clueNumber: 79}],
		4: [{color: 'green', clueNumber: 62}, {color: 'blue', clueNumber: 1}, {color: 'orange', clueNumber: 78}, {color: 'purple', clueNumber: 65}],
		5: [{color: 'red', clueNumber: 91}, {color: 'green', clueNumber: 87}, {color: 'blue', clueNumber: 88}, {color: 'orange', clueNumber: 63}, {color: 'purple', clueNumber: 49}]
	}
};

// Clue book mappings (1-indexed in definition, 0-indexed for JS arrays)
const CLUE_BOOK_MAPPINGS = {
	A_Red: [47, 33, 38, 9, 7, 23, 3, 6, 32, 31, 21, 37, 44, 16, 5, 12, 48, 42, 39, 43, 46, 3, 24, 22, 27, 40, 27, 39, 29, 37, 41, 6, 43, 26, 8, 42, 14, 4, 23, 8, 22, 44, 11, 34, 1, 45, 10, 48, 12, 36, 2, 38, 20, 30, 45, 25, 28, 15, 17, 10, 26, 19, 1, 5, 35, 25, 11, 30, 35, 21, 9, 32, 7, 13, 4, 20, 28, 13, 14, 29, 18, 2, 46, 36, 40, 16, 18, 31, 15, 17, 47, 33, 41, 24, 34, 19],
	B_Green: [26, 48, 42, 6, 43, 35, 2, 30, 10, 17, 46, 11, 31, 20, 12, 47, 40, 8, 38, 17, 15, 41, 19, 4, 39, 5, 23, 29, 32, 24, 21, 34, 27, 42, 45, 33, 6, 10, 22, 14, 1, 37, 47, 12, 43, 36, 25, 23, 38, 3, 13, 22, 46, 39, 11, 2, 1, 41, 13, 18, 40, 31, 3, 44, 45, 48, 36, 16, 18, 4, 37, 5, 26, 33, 8, 28, 27, 20, 44, 35, 14, 28, 29, 9, 16, 34, 7, 24, 25, 30, 9, 32, 7, 21, 19, 15],
	C_Blue: [42, 40, 9, 30, 3, 42, 11, 6, 7, 21, 43, 45, 31, 17, 6, 21, 14, 25, 2, 26, 28, 4, 38, 15, 41, 18, 37, 44, 36, 20, 34, 32, 2, 19, 43, 37, 3, 23, 33, 44, 33, 18, 29, 47, 15, 13, 41, 26, 48, 48, 8, 23, 36, 47, 5, 10, 9, 12, 7, 1, 4, 16, 45, 8, 46, 10, 14, 35, 24, 34, 46, 19, 40, 28, 12, 13, 29, 22, 5, 25, 35, 16, 22, 39, 27, 24, 31, 17, 30, 1, 20, 27, 38, 39, 11, 32],
	D_Orange: [8, 47, 24, 38, 1, 17, 28, 7, 23, 16, 27, 2, 47, 39, 43, 21, 46, 21, 29, 40, 11, 41, 9, 33, 32, 35, 26, 4, 41, 37, 8, 18, 3, 25, 34, 44, 9, 22, 30, 32, 10, 39, 42, 14, 45, 35, 38, 20, 45, 31, 26, 46, 33, 5, 18, 44, 10, 36, 30, 6, 16, 12, 48, 23, 7, 17, 11, 22, 34, 19, 6, 48, 42, 29, 5, 3, 37, 27, 13, 4, 25, 12, 36, 40, 43, 31, 15, 14, 19, 20, 28, 13, 1, 15, 24, 2],
	E_Purple: [30, 37, 12, 5, 6, 18, 41, 27, 43, 22, 35, 23, 36, 14, 12, 44, 40, 11, 41, 4, 48, 40, 48, 2, 4, 29, 31, 43, 39, 45, 10, 1, 32, 38, 24, 3, 31, 32, 10, 5, 42, 37, 20, 33, 25, 3, 2, 30, 14, 42, 29, 44, 15, 8, 26, 23, 39, 16, 22, 21, 46, 25, 20, 16, 19, 34, 35, 38, 8, 17, 7, 28, 17, 19, 18, 26, 6, 27, 15, 9, 13, 46, 45, 33, 24, 47, 28, 9, 47, 1, 13, 36, 7, 21, 34, 11]
};

// Map color to clue book
const COLOR_TO_CLUE_BOOK = {
	red: 'A_Red',
	green: 'B_Green',
	blue: 'C_Blue',
	orange: 'D_Orange',
	purple: 'E_Purple'
};

function resolveRuleFromClue(color, clueNumber) {
	const bookKey = COLOR_TO_CLUE_BOOK[color];
	if (!bookKey || !CLUE_BOOK_MAPPINGS[bookKey]) return null;
	
	const mapping = CLUE_BOOK_MAPPINGS[bookKey];
	if (clueNumber < 1 || clueNumber > 96) return null;
	
	const ruleIndex = mapping[clueNumber - 1]; // Convert 1-indexed to 0-indexed
	const rule = RULES.find(r => r.id === String(ruleIndex));
	
	
	return rule ? rule.id : null;
}

const ANIMAL_GLYPH = { bear:'üêª', cougar:'üêæ' };

// ===== Types =====
/** @typedef {('desert'|'swamp'|'mountain'|'forest'|'water')} Terrain */
/** @typedef {('bear'|'cougar')} Animal */
/** @typedef {('standing_stone'|'abandoned_shack')} StructureType */
/** @typedef {('black'|'blue'|'green'|'white')} Color */
/** @typedef {{ q:number, r:number, terrain:Terrain, animals:Set<Animal>, structures:Array<{type:StructureType,color:Color}> }} Cell */

// ===== Board =====
const Board = { width:12, height:9, cells:new Map() };
const key = (q,r)=>`${q},${r}`;
function forEachCell(cb){ for(const c of Board.cells.values()) cb(c); }
function cellAt(q,r){ let c=Board.cells.get(key(q,r)); if(!c){ c={q,r,terrain:'water',animals:new Set(),structures:[]}; Board.cells.set(key(q,r),c);} return c; }
function hexDist(a,b){
	// Correct odd-q (vertical columns) distance via cube coords
	function toCube(q,r){
		const x = q;
		const z = r - ((q - (q & 1)) / 2);
		const y = -x - z;
		return {x,y,z};
	}
	const ac = toCube(a.q,a.r);
	const bc = toCube(b.q,b.r);
	const dx = Math.abs(ac.x - bc.x);
	const dy = Math.abs(ac.y - bc.y);
	const dz = Math.abs(ac.z - bc.z);
	return (dx + dy + dz) / 2;
}

// ===== Tiles (2√ó3 grid of 6√ó3 hexes each) =====
const TILE_W = 6, TILE_H = 3;
/** @typedef {{ terrain: Terrain[][], animals: Array<{x:number,y:number, animal:Animal}>, structures: Array<{x:number,y:number, type:StructureType, color:Color}> }} TileDef */

// Default tiles with animals (from your last message)
const DEFAULT_TILES = {
  "1": {"terrain":[["water","water","water","water","forest","forest"],["swamp","swamp","water","desert","forest","forest"],["swamp","swamp","desert","desert","desert","forest"]],"animals":[{"x":3,"y":2,"animal":"bear"},{"x":4,"y":2,"animal":"bear"}],"structures":[]},
  "2": {"terrain":[["swamp","forest","forest","forest","forest","forest"],["swamp","swamp","forest","desert","desert","desert"],["swamp","mountain","mountain","mountain","mountain","desert"]],"animals":[{"x":0,"y":0,"animal":"cougar"},{"x":1,"y":0,"animal":"cougar"},{"x":2,"y":0,"animal":"cougar"}],"structures":[]},
  "3": {"terrain":[["swamp","swamp","forest","forest","forest","water"],["swamp","swamp","forest","mountain","water","water"],["mountain","mountain","mountain","mountain","water","water"]],"animals":[{"x":0,"y":1,"animal":"cougar"},{"x":1,"y":1,"animal":"cougar"},{"x":0,"y":2,"animal":"cougar"}],"structures":[]},
  "4": {"terrain":[["desert","desert","mountain","mountain","mountain","mountain"],["desert","desert","mountain","water","water","water"],["desert","desert","desert","forest","forest","forest"]],"animals":[{"x":5,"y":1,"animal":"cougar"},{"x":5,"y":2,"animal":"cougar"}],"structures":[]},
  "5": {"terrain":[["swamp","swamp","swamp","mountain","mountain","mountain"],["swamp","desert","desert","water","mountain","mountain"],["desert","desert","water","water","water","water"]],"animals":[{"x":5,"y":1,"animal":"bear"},{"x":4,"y":2,"animal":"bear"},{"x":5,"y":2,"animal":"bear"}],"structures":[]},
  "6": {"terrain":[["desert","desert","swamp","swamp","swamp","forest"],["mountain","mountain","swamp","swamp","forest","forest"],["mountain","water","water","water","water","forest"]],"animals":[{"x":0,"y":0,"animal":"bear"},{"x":0,"y":1,"animal":"bear"}],"structures":[]}
};
/** @type {Record<number, TileDef>} */
let TILES = structuredClone(DEFAULT_TILES);
let lastArrangement = null; // Array<{id:number, flipped:boolean, col:number, row:number}>
let showTileLabels = true;

// ===== Geometry: FLAT-TOP, odd-q offset =====
const svg = document.getElementById('hexsvg');
svg.addEventListener('mousedown', (e)=>{ if(e.shiftKey) e.preventDefault(); });
const svgNS = 'http://www.w3.org/2000/svg';
let HEX_SIZE = 26;
function hexToPoint(q,r){
	const x = 1.5 * HEX_SIZE * q;
	const y = Math.sqrt(3) * HEX_SIZE * (r + ((q & 1) ? 0.5 : 0));
	return {x,y};
}
function polygonPoints(cx,cy,size){
	const pts=[];
	for(let i=0;i<6;i++){
		const ang = Math.PI/180 * (60*i);
		pts.push([cx + size*Math.cos(ang), cy + size*Math.sin(ang)]);
	}
	return pts.map(([x,y])=>x.toFixed(2)+","+y.toFixed(2)).join(' ');
}
function regularPolygonPoints(cx, cy, radius, sides, rotationDeg=0){
	const pts=[]; const rot = Math.PI/180 * rotationDeg;
	for(let i=0;i<sides;i++){
		const ang = rot + i * (2*Math.PI/sides);
		pts.push([cx + radius*Math.cos(ang), cy + radius*Math.sin(ang)]);
	}
	return pts.map(([x,y])=>x.toFixed(2)+","+y.toFixed(2)).join(' ');
}

function draw(perRuleOverlays, uniqueKey, selectedRuleOverlay, showHabitat = true, habitatCells = null){
	svg.innerHTML='';
	// tight viewBox
	const Rx = HEX_SIZE, Ry = Math.sqrt(3)*HEX_SIZE/2;
	let minX=Infinity, minY=Infinity, maxX=-Infinity, maxY=-Infinity;
	const centers=new Map();
	forEachCell(c=>{ const p=hexToPoint(c.q,c.r); centers.set(key(c.q,c.r),p);
		minX=Math.min(minX,p.x-Rx); maxX=Math.max(maxX,p.x+Rx);
		minY=Math.min(minY,p.y-Ry); maxY=Math.max(maxY,p.y+Ry); });
	const pad=HEX_SIZE*1.2; svg.setAttribute('viewBox', `${minX-pad} ${minY-pad} ${maxX-minX+pad*2} ${maxY-minY+pad*2}`);

	forEachCell(c=>{
		const {x,y}=centers.get(key(c.q,c.r));
		const g=document.createElementNS(svgNS,'g'); g.setAttribute('transform',`translate(${x},${y})`); g.dataset.q=String(c.q); g.dataset.r=String(c.r);
		// base
		const poly=document.createElementNS(svgNS,'polygon'); poly.setAttribute('points', polygonPoints(0,0,HEX_SIZE)); poly.setAttribute('fill',TERRAIN_COLORS[c.terrain]); poly.setAttribute('stroke','#0b1220'); poly.setAttribute('stroke-width','1'); g.appendChild(poly);
		// animals
		if(c.animals.size){ const t=document.createElementNS(svgNS,'text'); t.setAttribute('x','0'); t.setAttribute('y','-6'); t.setAttribute('text-anchor','middle'); t.setAttribute('font-size','16'); t.setAttribute('font-weight','700'); t.textContent=[...c.animals].map(a=>ANIMAL_GLYPH[a]).join(''); g.appendChild(t); }
		// structures
		if(c.structures.length){
			const sG=document.createElementNS(svgNS,'g');
			sG.setAttribute('transform','translate(0,8)');
			c.structures.slice(0,3).forEach((s,i)=>{
				const dx=-12 + i*12;
				if(s.type==='standing_stone'){
					const p=document.createElementNS(svgNS,'polygon');
					p.setAttribute('points', regularPolygonPoints(dx,0,5.5,8,22.5));
					p.setAttribute('fill', STRUCT_COLORS[s.color]);
					p.setAttribute('stroke', '#0b1220'); p.setAttribute('stroke-width','1');
					sG.appendChild(p);
				} else {
					const p=document.createElementNS(svgNS,'polygon');
					p.setAttribute('points', regularPolygonPoints(dx,0,6,3,-90));
					p.setAttribute('fill', STRUCT_COLORS[s.color]);
					p.setAttribute('stroke', '#0b1220'); p.setAttribute('stroke-width','1');
					sG.appendChild(p);
				}
			});
			g.appendChild(sG);
		}
		// per-rule outlines (use player colors if provided)
		if(Array.isArray(perRuleOverlays)){
			perRuleOverlays.forEach((ov,i)=>{ if(ov.set.has(key(c.q,c.r))){ const inset=3+i*3; const hl=document.createElementNS(svgNS,'polygon'); hl.setAttribute('points', polygonPoints(0,0,Math.max(HEX_SIZE-inset,6))); hl.setAttribute('fill','none'); hl.setAttribute('stroke', ov.color || RULE_COLORS[i%RULE_COLORS.length]); hl.setAttribute('stroke-width','3'); g.appendChild(hl);} });
		}
		
		// selected rule overlay (black outline with smallest radius, drawn last so it's on top)
		if(selectedRuleOverlay && selectedRuleOverlay.set.has(key(c.q,c.r))){
			const maxInset = 3 + (perRuleOverlays ? perRuleOverlays.length * 3 : 0);
			const hl=document.createElementNS(svgNS,'polygon'); 
			hl.setAttribute('points', polygonPoints(0,0,Math.max(HEX_SIZE-maxInset-3,4))); 
			hl.setAttribute('fill','none'); 
			hl.setAttribute('stroke','#000000'); 
			hl.setAttribute('stroke-width','2'); 
			g.appendChild(hl);
		}
		
		// habitat cells (show target emoji for all cells in final intersection)
		if(habitatCells && habitatCells.has(key(c.q,c.r)) && showHabitat){
			const habitat=document.createElementNS(svgNS,'text'); 
			habitat.setAttribute('x','0'); 
			habitat.setAttribute('y','4'); 
			habitat.setAttribute('text-anchor','middle'); 
			habitat.setAttribute('font-size','20'); 
			habitat.setAttribute('font-weight','700');
			habitat.setAttribute('fill','#fbbf24');
			habitat.setAttribute('stroke','#000000');
			habitat.setAttribute('stroke-width','1');
			habitat.style.paintOrder='stroke';
			habitat.textContent='üéØ'; 
			g.appendChild(habitat);
		}
		g.addEventListener('click', onHexClick); svg.appendChild(g);
	});

	// tile number labels
	if(showTileLabels && Array.isArray(lastArrangement)){
		lastArrangement.forEach(arr=>{
			const q0 = arr.col * TILE_W, r0 = arr.row * TILE_H;
			const corner = arr.flipped ? hexToPoint(q0 + TILE_W - 1, r0 + TILE_H - 1) : hexToPoint(q0, r0);
			const tx = arr.flipped ? corner.x + HEX_SIZE * 0.7 : corner.x - HEX_SIZE * 0.7;
			const ty = arr.flipped ? corner.y + HEX_SIZE * 0.7 : corner.y - HEX_SIZE * 0.7;
			const t = document.createElementNS(svgNS,'text');
			t.setAttribute('x', String(tx)); t.setAttribute('y', String(ty));
			t.setAttribute('text-anchor', arr.flipped ? 'end' : 'start');
			t.setAttribute('dominant-baseline', arr.flipped ? 'ideographic' : 'hanging');
			t.setAttribute('font-size','18'); t.setAttribute('font-weight','800');
			t.setAttribute('fill','#f8fafc'); t.setAttribute('stroke','#000'); t.setAttribute('stroke-width','3'); t.style.paintOrder='stroke';
			t.textContent = String(arr.id);
			svg.appendChild(t);
		});
	}
}

let habitatCellSet = null; // Global variable to store habitat cells

function redrawWithSelection(){
	let selectedRuleOverlay = null;
	if(selectedRuleId){
		const rule = RULES.find(r => r.id === selectedRuleId);
		if(rule){
			const validCells = evalRule(rule);
			selectedRuleOverlay = { set: validCells };
		}
	}
	const showHabitat = document.getElementById('showHabitat')?.checked ?? true;
	draw(latestPerRule, latestUniqueKey, selectedRuleOverlay, showHabitat, habitatCellSet);
	updateRuleCounts();
}

// ===== Painting =====
let currentTerrain = /** @type {Terrain} */ ('desert');
let currentMarker = /** @type {{ kind:'animal'|'structure'|null, value?:any }} */ ({ kind:null });
function onHexClick(e){
	e.preventDefault(); e.stopPropagation();
	const g=e.currentTarget; const q=+g.dataset.q; const r=+g.dataset.r; const c=cellAt(q,r);
	if(e.altKey){ c.animals.clear(); c.structures=[]; redrawWithSelection(); return; }
	if(e.shiftKey){
		if(currentMarker.kind==='animal'){
			if(c.animals.has(currentMarker.value)) c.animals.delete(currentMarker.value); else c.animals.add(currentMarker.value);
		}
		else if(currentMarker.kind==='structure'){
			const {type,color}=currentMarker.value||{};
			if(type && color){
				const idx=c.structures.findIndex(s=>s.type===type && s.color===color);
				if(idx>=0) c.structures.splice(idx,1); else c.structures.push({type,color});
			}
		}
	}
	else { c.terrain=currentTerrain; }
	redrawWithSelection();
}

// ===== Palettes =====
const terrainPalette=document.getElementById('terrainPalette');
const markerPalette=document.getElementById('markerPalette');
function buildPalettes(){
	terrainPalette.innerHTML=''; TERRAIN.forEach(t=>{ const li=document.createElement('li'); li.style.cursor='pointer'; li.innerHTML=`<span class='sw' style='background:${TERRAIN_COLORS[t]}'></span>${t}`; li.addEventListener('click',()=>{ currentTerrain=t; highlightSelected(terrainPalette, li); }); terrainPalette.appendChild(li); }); highlightSelected(terrainPalette, terrainPalette.firstElementChild);
	markerPalette.innerHTML=''; const none=document.createElement('li'); none.textContent='‚Äî none ‚Äî'; none.style.cursor='pointer'; none.addEventListener('click',()=>{ currentMarker={kind:null}; highlightSelected(markerPalette, none); }); markerPalette.appendChild(none);
	ANIMALS.forEach(a=>{ const li=document.createElement('li'); li.style.cursor='pointer'; li.textContent=`${a} ${ANIMAL_GLYPH[a]}`; li.addEventListener('click',()=>{ currentMarker={kind:'animal', value:a}; highlightSelected(markerPalette, li); }); markerPalette.appendChild(li); });
	STRUCT_TYPES.forEach(st=>{ COLORS.forEach(col=>{ const li=document.createElement('li'); li.style.cursor='pointer'; li.innerHTML=`<span class='colorChip' style='background:${STRUCT_COLORS[col]}'></span> ${col} ${st.replace('_',' ')}`; li.addEventListener('click',()=>{ currentMarker={kind:'structure', value:{type:st,color:col}}; highlightSelected(markerPalette, li); }); markerPalette.appendChild(li); }); });
	highlightSelected(markerPalette, none);
}
function highlightSelected(list, el){ [...list.children].forEach(c=>c.style.outline=''); if(el) el.style.outline='2px solid #22d3ee'; }

// ===== Tile helpers =====
function blankBoard(){
	Board.cells.clear();
	for(let r=0;r<Board.height;r++){
		for(let q=0;q<Board.width;q++){
			const c=cellAt(q,r); c.terrain='water'; c.animals.clear(); c.structures=[];
		}
	}
}
function mapXY(x,y, flipped){ return flipped ? {x:TILE_W-1-x, y:TILE_H-1-y} : {x,y}; }
function stampTile(tileId, flipped, col, row){
	const def = TILES[Number(tileId)]; if(!def) return;
	const q0 = col * TILE_W, r0 = row * TILE_H;
	for(let y=0;y<TILE_H;y++){
		for(let x=0;x<TILE_W;x++){
			const m = mapXY(x,y, flipped);
			const c = cellAt(q0+x, r0+y);
			c.terrain = def.terrain[m.y][m.x];
			c.animals.clear(); c.structures=[];
		}
	}
	(def.animals||[]).forEach(a=>{ const m=mapXY(a.x,a.y,flipped); cellAt(q0+m.x, r0+m.y).animals.add(a.animal); });
	(def.structures||[]).forEach(s=>{ const m=mapXY(s.x,s.y,flipped); cellAt(q0+m.x, r0+m.y).structures.push({type:s.type, color:s.color}); });
}
function parseArrangement(str){
	const nums = (str.match(/[+-]?[0-9]+/g)||[]).map(n=>parseInt(n,10));
	if(nums.length!==6) throw new Error('Provide six signed integers 1..6');
	const abs = nums.map(n=>Math.abs(n));
	if(abs.some(n=>n<1||n>6)) throw new Error('Tile ids must be 1..6');
	const uniq = new Set(abs); if(uniq.size!==6) throw new Error('Tile ids must not repeat');
	return nums.map((n,i)=>({ id:Math.abs(n), flipped:n<0, col:i%2, row:Math.floor(i/2) }));
}
function applyArrangementString(str, redraw=true){
	try{
		const arr = parseArrangement(str);
		lastArrangement = arr;
		blankBoard();
		arr.forEach(a=> stampTile(a.id, a.flipped, a.col, a.row));
		if(redraw){ redrawWithSelection(); }
	}catch(e){ alert(e.message); }
}

// ===== Import/Export (game) =====
const exportBtn=document.getElementById('exportGame');
const importBtn=document.getElementById('importGame');
const gameJSON=document.getElementById('gameJSON');

function exportGame() {
	// Get current tile arrangement
	const arrangementStr = document.getElementById('arrangementStr').value || "1 2 3 4 5 6";
	
	// Get all structures from the board
	const structures = [];
	forEachCell(c => {
		if (c.structures.length > 0) {
			c.structures.forEach(s => {
				structures.push({
					type: s.type,
					color: s.color,
					q: c.q,
					r: c.r
				});
			});
		}
	});
	
	// Create game data
	const gameData = {
		tileArrangement: arrangementStr,
		structures: structures,
		playerConfigs: {
			3: GAME_CONFIGURATIONS[3],
			4: GAME_CONFIGURATIONS[4], 
			5: GAME_CONFIGURATIONS[5]
		}
	};
	
	gameJSON.value = JSON.stringify(gameData, null, 2);
}

function importGame() {
	try {
		const gameData = JSON.parse(gameJSON.value);
		
		// Apply tile arrangement
		document.getElementById('arrangementStr').value = gameData.tileArrangement || "1 2 3 4 5 6";
		applyArrangementString(gameData.tileArrangement || "1 2 3 4 5 6", false);
		
		// Place structures
		if (gameData.structures) {
			gameData.structures.forEach(s => {
				const cell = cellAt(s.q, s.r);
				cell.structures.push({
					type: s.type,
					color: s.color
				});
			});
		}
		
		// Load player configurations
		if (gameData.playerConfigs) {
			GAME_CONFIGURATIONS[3] = gameData.playerConfigs[3] || [];
			GAME_CONFIGURATIONS[4] = gameData.playerConfigs[4] || [];
			GAME_CONFIGURATIONS[5] = gameData.playerConfigs[5] || [];
		}
		
		// Update current player assignments based on current player count
		updatePlayerAssignmentsFromConfig();
		
		rebuildAssignmentsUI();
		redrawWithSelection();
		
	} catch(e) { 
		alert('Invalid Game JSON: ' + e.message); 
	}
}

function updatePlayerAssignmentsFromConfig() {
	const p = +playersSel.value;
	const config = GAME_CONFIGURATIONS[p] || [];
	const defaultColors = DEFAULT_PLAYER_COLORS_BY_COUNT[p] || PLAYER_COLOR_ORDER.slice(0,p);
	
	// Ensure PLAYER_ASSIGNMENTS has the right length
	while(PLAYER_ASSIGNMENTS.length < p) {
		PLAYER_ASSIGNMENTS.push({
			color: defaultColors[PLAYER_ASSIGNMENTS.length] || PLAYER_COLOR_ORDER[PLAYER_ASSIGNMENTS.length],
			ruleId: null,
			clueNumber: null
		});
	}
	PLAYER_ASSIGNMENTS.length = p; // Trim if too long
	
	// Update PLAYER_ASSIGNMENTS with config data
	config.forEach((cfg, i) => {
		if (i < PLAYER_ASSIGNMENTS.length) {
			PLAYER_ASSIGNMENTS[i].color = cfg.color;
			PLAYER_ASSIGNMENTS[i].clueNumber = cfg.clueNumber;
			PLAYER_ASSIGNMENTS[i].ruleId = resolveRuleFromClue(cfg.color, cfg.clueNumber);
		}
	});
}

function saveCurrentAssignmentsToConfig() {
	const p = +playersSel.value;
	GAME_CONFIGURATIONS[p] = PLAYER_ASSIGNMENTS.map(a => ({
		color: a.color,
		clueNumber: a.clueNumber
	})).filter(cfg => cfg.clueNumber !== null);
}

function loadDefaultGame() {
	// Apply tile arrangement
	document.getElementById('arrangementStr').value = DEFAULT_GAME.tileArrangement;
	applyArrangementString(DEFAULT_GAME.tileArrangement, false);
	
	// Place structures
	DEFAULT_GAME.structures.forEach(s => {
		const cell = cellAt(s.q, s.r);
		cell.structures.push({
			type: s.type,
			color: s.color
		});
	});
	
	// Load player configurations
	GAME_CONFIGURATIONS[3] = [...DEFAULT_GAME.playerConfigs[3]];
	GAME_CONFIGURATIONS[4] = [...DEFAULT_GAME.playerConfigs[4]];
	GAME_CONFIGURATIONS[5] = [...DEFAULT_GAME.playerConfigs[5]];
	
	// Display the default game JSON in the text area
	gameJSON.value = JSON.stringify(DEFAULT_GAME, null, 2);
	
	// Update current player assignments based on current player count
	updatePlayerAssignmentsFromConfig();
}

exportBtn.addEventListener('click', exportGame);
importBtn.addEventListener('click', importGame);

// (Tiles are fixed to the standard 6; no capture/export/import UI)
// ===== Tile UI wires =====
const arrangementStr = document.getElementById('arrangementStr');
const applyArrangementBtn = document.getElementById('applyArrangement');
const toggleTileLabelsBtn = document.getElementById('toggleTileLabels');
applyArrangementBtn.addEventListener('click', ()=> applyArrangementString(arrangementStr.value||'1 2 3 4 5 6'));
arrangementStr.addEventListener('keydown', (e)=>{ if(e.key==='Enter'){ e.preventDefault(); applyArrangementString(arrangementStr.value||'1 2 3 4 5 6'); }});

toggleTileLabelsBtn.addEventListener('click', ()=>{ showTileLabels=!showTileLabels; redrawWithSelection(); });


// ===== Rules =====
/** @typedef {{ id:string, label:string, negated:boolean, within:0|1|2|3, targets:Array<{kind:'terrain',terrain:Terrain[]}|{kind:'animal',animal:Animal[]}|{kind:'structure',type:StructureType[],colors:Color[] }>, players:number[] }} Rule */
const DEFAULT_RULES=(()=>{
	const rules=[];
	let id=1;
	const add=(label,negated,within,targets,players)=>rules.push({id:String(id++),label,negated,within,targets,players});
	
	// Canonical rules 1-48 from the cryptid cluebooks (exact order and text)
	add('not on desert or mountain',true,0,[{kind:'terrain',terrain:['desert','mountain']}],[3,4,5]);
	add('not on desert or swamp',true,0,[{kind:'terrain',terrain:['desert','swamp']}],[3,4,5]);
	add('not on desert or water',true,0,[{kind:'terrain',terrain:['desert','water']}],[3,4,5]);
	add('not on forest or desert',true,0,[{kind:'terrain',terrain:['forest','desert']}],[3,4,5]);
	add('not on forest or mountain',true,0,[{kind:'terrain',terrain:['forest','mountain']}],[3,4,5]);
	add('not on forest or swamp',true,0,[{kind:'terrain',terrain:['forest','swamp']}],[3,4,5]);
	add('not on forest or water',true,0,[{kind:'terrain',terrain:['forest','water']}],[3,4,5]);
	add('not on swamp or mountain',true,0,[{kind:'terrain',terrain:['swamp','mountain']}],[3,4,5]);
	add('not on water or mountains',true,0,[{kind:'terrain',terrain:['water','mountain']}],[3,4,5]);
	add('not on water or swamp',true,0,[{kind:'terrain',terrain:['water','swamp']}],[3,4,5]);
	add('not within one space of desert',true,1,[{kind:'terrain',terrain:['desert']}],[3,4,5]);
	add('not within one space of either animal territory',true,1,[{kind:'animal',animal:['bear','cougar']}],[3,4,5]);
	add('not within one space of forest',true,1,[{kind:'terrain',terrain:['forest']}],[3,4,5]);
	add('not within one space of mountain',true,1,[{kind:'terrain',terrain:['mountain']}],[3,4,5]);
	add('not within one space of swamp',true,1,[{kind:'terrain',terrain:['swamp']}],[3,4,5]);
	add('not within one space of water',true,1,[{kind:'terrain',terrain:['water']}],[3,4,5]);
	add('not within three spaces of a black structure',true,3,[{kind:'structure',type:['standing_stone','abandoned_shack'],colors:['black']}],[3,4,5]);
	add('not within three spaces of a blue structure',true,3,[{kind:'structure',type:['standing_stone','abandoned_shack'],colors:['blue']}],[3,4,5]);
	add('not within three spaces of a green structure',true,3,[{kind:'structure',type:['standing_stone','abandoned_shack'],colors:['green']}],[3,4,5]);
	add('not within three spaces of a white structure',true,3,[{kind:'structure',type:['standing_stone','abandoned_shack'],colors:['white']}],[3,4,5]);
	add('not within two spaces of a standing stone',true,2,[{kind:'structure',type:['standing_stone'],colors:['black','blue','green','white']}],[3,4,5]);
	add('not within two spaces of an abandoned shack',true,2,[{kind:'structure',type:['abandoned_shack'],colors:['black','blue','green','white']}],[3,4,5]);
	add('not within two spaces of bear territory',true,2,[{kind:'animal',animal:['bear']}],[3,4,5]);
	add('not within two spaces of cougar territory',true,2,[{kind:'animal',animal:['cougar']}],[3,4,5]);
	add('on desert or mountain',false,0,[{kind:'terrain',terrain:['desert','mountain']}],[3,4,5]);
	add('on desert or swamp',false,0,[{kind:'terrain',terrain:['desert','swamp']}],[3,4,5]);
	add('on desert or water',false,0,[{kind:'terrain',terrain:['desert','water']}],[3,4,5]);
	add('on forest or desert',false,0,[{kind:'terrain',terrain:['forest','desert']}],[3,4,5]);
	add('on forest or mountain',false,0,[{kind:'terrain',terrain:['forest','mountain']}],[3,4,5]);
	add('on forest or swamp',false,0,[{kind:'terrain',terrain:['forest','swamp']}],[3,4,5]);
	add('on forest or water',false,0,[{kind:'terrain',terrain:['forest','water']}],[3,4,5]);
	add('on swamp or mountain',false,0,[{kind:'terrain',terrain:['swamp','mountain']}],[3,4,5]);
	add('on water or mountains',false,0,[{kind:'terrain',terrain:['water','mountain']}],[3,4,5]);
	add('on water or swamp',false,0,[{kind:'terrain',terrain:['water','swamp']}],[3,4,5]);
	add('within one space of desert',false,1,[{kind:'terrain',terrain:['desert']}],[3,4,5]);
	add('within one space of either animal territory',false,1,[{kind:'animal',animal:['bear','cougar']}],[3,4,5]);
	add('within one space of forest',false,1,[{kind:'terrain',terrain:['forest']}],[3,4,5]);
	add('within one space of mountain',false,1,[{kind:'terrain',terrain:['mountain']}],[3,4,5]);
	add('within one space of swamp',false,1,[{kind:'terrain',terrain:['swamp']}],[3,4,5]);
	add('within one space of water',false,1,[{kind:'terrain',terrain:['water']}],[3,4,5]);
	add('within three spaces of a black structure',false,3,[{kind:'structure',type:['standing_stone','abandoned_shack'],colors:['black']}],[3,4,5]);
	add('within three spaces of a blue structure',false,3,[{kind:'structure',type:['standing_stone','abandoned_shack'],colors:['blue']}],[3,4,5]);
	add('within three spaces of a green structure',false,3,[{kind:'structure',type:['standing_stone','abandoned_shack'],colors:['green']}],[3,4,5]);
	add('within three spaces of a white structure',false,3,[{kind:'structure',type:['standing_stone','abandoned_shack'],colors:['white']}],[3,4,5]);
	add('within two spaces of a standing stone',false,2,[{kind:'structure',type:['standing_stone'],colors:['black','blue','green','white']}],[3,4,5]);
	add('within two spaces of an abandoned shack',false,2,[{kind:'structure',type:['abandoned_shack'],colors:['black','blue','green','white']}],[3,4,5]);
	add('within two spaces of bear territory',false,2,[{kind:'animal',animal:['bear']}],[3,4,5]);
	add('within two spaces of cougar territory',false,2,[{kind:'animal',animal:['cougar']}],[3,4,5]);
	
	return rules;
})();
let RULES=structuredClone(DEFAULT_RULES);

const ruleList=document.getElementById('ruleList'); const playersSel=document.getElementById('players');

function rebuildRuleList(){
	ruleList.innerHTML='';
	const p=+playersSel.value; const subset=RULES.filter(r=>r.players.includes(p));
	subset.forEach((r,i)=>{
		const row=document.createElement('div'); row.className='ruleItem'; row.dataset.id=r.id;
		const label=document.createElement('div'); label.textContent=r.label; label.style.cursor='pointer';
		const count=document.createElement('div'); count.id=`rc_${r.id}`; count.className='small'; count.textContent='';
		
		// Make rule selectable
		row.style.cursor='pointer';
		row.addEventListener('click', ()=>{
			// Clear previous selection
			document.querySelectorAll('.ruleItem').forEach(item => {
				item.style.backgroundColor = '';
				item.style.border = '';
			});
			
			// Toggle selection
			if(selectedRuleId === r.id){
				selectedRuleId = null;
				row.style.backgroundColor = '';
				row.style.border = '';
			} else {
				selectedRuleId = r.id;
				row.style.backgroundColor = '#0b1220';
				row.style.border = '2px solid #22d3ee';
			}
			
			// Redraw with selected rule highlighted
			redrawWithSelection();
		});
		
		// Restore selection visual state if this rule is selected
		if(selectedRuleId === r.id){
			row.style.backgroundColor = '#0b1220';
			row.style.border = '2px solid #22d3ee';
		}
		
		row.appendChild(label); row.appendChild(count);ruleList.appendChild(row);
	});
}

// counts for all visible rules (auto)
function updateRuleCounts(){
	const p=+playersSel.value; const subset=RULES.filter(r=>r.players.includes(p));
	subset.forEach(r=>{ const s=evalRule(r); const el=document.getElementById(`rc_${r.id}`); if(el) el.textContent=String(s.size); });
}

// ===== Players & assignments =====
function visibleRules(){ const p=+playersSel.value; return RULES.filter(r=>r.players.includes(p)); }
function rebuildAssignmentsUI(){
	const host=document.getElementById('assignments'); if(!host) return; host.innerHTML='';
	const p=+playersSel.value;
	const defaultColors = DEFAULT_PLAYER_COLORS_BY_COUNT[p] || PLAYER_COLOR_ORDER.slice(0,p);
	// Get current config for this player count
	const currentConfig = GAME_CONFIGURATIONS[p] || [];
	
	if(PLAYER_ASSIGNMENTS.length!==p){
		PLAYER_ASSIGNMENTS = Array.from({length:p}, (_,i)=>{
			const configItem = currentConfig[i];
			if(configItem) {
				return {
					color: configItem.color,
					clueNumber: configItem.clueNumber,
					ruleId: resolveRuleFromClue(configItem.color, configItem.clueNumber)
				};
			} else {
				return {
					color: defaultColors[i]||PLAYER_COLOR_ORDER[i], 
					ruleId: null,
					clueNumber: null
				};
			}
		});
	} else {
		PLAYER_ASSIGNMENTS.forEach((a,i)=>{ 
			const configItem = currentConfig[i];
			if(configItem && (!a || !a.color)) {
				PLAYER_ASSIGNMENTS[i] = {
					color: configItem.color,
					clueNumber: configItem.clueNumber,
					ruleId: resolveRuleFromClue(configItem.color, configItem.clueNumber)
				};
			} else if(!a||!a.color){ 
				PLAYER_ASSIGNMENTS[i]={ 
					color: defaultColors[i]||PLAYER_COLOR_ORDER[i], 
					ruleId: a?a.ruleId:null,
					clueNumber: a?a.clueNumber:null
				}; 
			} 
		});
	}
	
	PLAYER_ASSIGNMENTS.forEach((a,idx)=>{
		const row=document.createElement('div'); row.className='row';
		const label=document.createElement('label'); label.textContent=`Player ${idx+1}`; label.style.minWidth='70px';
		const chip=document.createElement('span'); chip.className='colorChip'; chip.style.background=PLAYER_COLORS[a.color]; chip.style.marginRight='6px';
		
		const colorSel=document.createElement('select');
		PLAYER_COLOR_ORDER.forEach(c=>{ const opt=document.createElement('option'); opt.value=c; opt.textContent=c; opt.selected=(a.color===c); colorSel.appendChild(opt); });
		colorSel.addEventListener('change', ()=>{ 
			a.color=colorSel.value; 
			chip.style.background=PLAYER_COLORS[a.color]; 
			// Re-resolve rule when color changes
			if (a.clueNumber) {
				const newRuleId = resolveRuleFromClue(a.color, a.clueNumber);
				a.ruleId = newRuleId;
				updateRuleDisplay(a, ruleDisplay, cellCount);
			}
			// Save current assignments to game configurations
			saveCurrentAssignmentsToConfig();
		});
		
		const clueInput=document.createElement('input');
		clueInput.type='number';
		clueInput.min='1';
		clueInput.max='96';
		clueInput.placeholder='1-96';
		clueInput.style.width='60px';
		clueInput.style.marginLeft='6px';
		if (a.clueNumber) clueInput.value = a.clueNumber;
		
		const ruleDisplay=document.createElement('span');
		ruleDisplay.style.fontSize='12px';
		ruleDisplay.style.color='var(--muted)';
		ruleDisplay.style.marginLeft='6px';
		ruleDisplay.style.cursor='pointer';
		ruleDisplay.style.textDecoration='underline';
		
		const cellCount=document.createElement('span');
		cellCount.style.fontSize='12px';
		cellCount.style.color='var(--muted)';
		cellCount.style.marginLeft='6px';
		cellCount.style.fontWeight='bold';
		
		function updateRuleDisplay(assignment, displayElement, countElement) {
			if (assignment.ruleId) {
				const rule = RULES.find(r => r.id === assignment.ruleId);
				if (rule) {
					displayElement.textContent = rule.label;
					// Calculate cell count
					const cellSet = evalRule(rule);
					countElement.textContent = `(${cellSet.size})`;
					
					// Make clickable to select in rule list
					displayElement.onclick = () => {
						// Clear previous selection
						document.querySelectorAll('.ruleItem').forEach(item => {
							item.style.backgroundColor = '';
							item.style.border = '';
						});
						
						// Select this rule in the list
						selectedRuleId = rule.id;
						const ruleItem = document.querySelector(`.ruleItem[data-id="${rule.id}"]`);
						if (ruleItem) {
							ruleItem.style.backgroundColor = '#0b1220';
							ruleItem.style.border = '2px solid #22d3ee';
						}
						
						// Redraw with selected rule highlighted
						redrawWithSelection();
					};
				} else {
					displayElement.textContent = '(unknown rule)';
					countElement.textContent = '';
					displayElement.onclick = null;
				}
			} else {
				displayElement.textContent = '';
				countElement.textContent = '';
				displayElement.onclick = null;
			}
		}
		
		clueInput.addEventListener('input', ()=>{ 
			const clueNum = parseInt(clueInput.value, 10);
			if (clueNum >= 1 && clueNum <= 96) {
				a.clueNumber = clueNum;
				const ruleId = resolveRuleFromClue(a.color, clueNum);
				a.ruleId = ruleId;
				updateRuleDisplay(a, ruleDisplay, cellCount);
			} else {
				a.clueNumber = null;
				a.ruleId = null;
				ruleDisplay.textContent = '';
				cellCount.textContent = '';
			}
			// Save current assignments to game configurations
			saveCurrentAssignmentsToConfig();
		});
		
		// Initial rule display
		updateRuleDisplay(a, ruleDisplay, cellCount);
		
		row.appendChild(label); 
		row.appendChild(chip); 
		row.appendChild(colorSel); 
		row.appendChild(clueInput);
		row.appendChild(ruleDisplay);
		row.appendChild(cellCount);
		host.appendChild(row);
	});
}

// ===== Evaluate =====
function evalRule(rule){
	const good=new Set();
	forEachCell(c=>{
		let hit=false;
		for(const t of rule.targets){
			if(t.kind==='terrain'){
				if(rule.within===0){ if(t.terrain.includes(c.terrain)) hit=true; }
				else { forEachCell(c2=>{ if(!hit && t.terrain.includes(c2.terrain) && hexDist(c,c2)<=rule.within) hit=true; }); }
			} else if(t.kind==='animal'){
				if(rule.within>0){ forEachCell(c2=>{ if(!hit){ const has=t.animal.some(a=>c2.animals.has(a)); if(has && hexDist(c,c2)<=rule.within) hit=true; } }); }
			} else if(t.kind==='structure'){
				if(rule.within>0){ forEachCell(c2=>{ if(!hit){ const any=c2.structures.some(s=>t.type.includes(s.type)&&t.colors.includes(s.color)); if(any && hexDist(c,c2)<=rule.within) hit=true; } }); }
			}
			if(hit) break;
		}
		const ok=rule.negated?!hit:hit;
		if(ok) good.add(key(c.q,c.r));
	});
	return good;
}
let latestPerRule=null, latestUniqueKey=null;
let selectedRuleId=null; // Track the currently selected rule for inspection
const evaluateBtn=document.getElementById('evaluate');
const clearHighlightsBtn=document.getElementById('clearHighlights');
const resultSummary=document.getElementById('resultSummary');

evaluateBtn.addEventListener('click',()=>{
	const p=+playersSel.value; const subset=RULES.filter(r=>r.players.includes(p));
	const byId=new Map(subset.map(r=>[r.id,r]));
	
	// Get active assignments with their original indices
	const activeAssignments = PLAYER_ASSIGNMENTS.map((a,idx)=>({...a, originalIndex:idx})).filter(a=>a.ruleId);
	const act = activeAssignments.map(a=>byId.get(a.ruleId)).filter(Boolean);
	
	if(act.length===0){ latestPerRule=null; latestUniqueKey=null; redrawWithSelection(); resultSummary.textContent='No assigned rules.'; return; }
	
	const per = act.map((r,i)=>[r, evalRule(r), activeAssignments[i]]);
	per.forEach(([r,s])=>{ const el=document.getElementById(`rc_${r.id}`); if(el) el.textContent=`${s.size}`; });
	
	const overlays = per.map(([r,s,assignment])=>({id:r.id,set:s,color: PLAYER_COLORS[assignment.color] }));
	let acc=null; per.forEach(([_,s])=>{ acc = acc? intersect(acc,s): s; });
	const uniqKey=acc.size===1?[...acc][0]:null;
	
	// Store habitat cells for visualization
	habitatCellSet = acc;
	
	latestPerRule=overlays; latestUniqueKey=uniqKey; redrawWithSelection();
	const lines=[`Assigned rules: ${act.length}`, `Intersection: ${acc.size}`];
	per.slice(0,5).forEach(([r,s,assignment],i)=>lines.push(`#P${assignment.originalIndex+1} ${r.label} ‚Üí ${s.size}`));
	resultSummary.textContent=lines.join('  |  ');
});
function intersect(a,b){ const out=new Set(); for(const v of a) if(b.has(v)) out.add(v); return out; }
clearHighlightsBtn.addEventListener('click',()=>{ latestPerRule=null; latestUniqueKey=null; redrawWithSelection(); resultSummary.textContent='‚Äî'; });

const showHabitatCheckbox = document.getElementById('showHabitat');
showHabitatCheckbox.addEventListener('change', ()=>{ redrawWithSelection(); });
playersSel.addEventListener('change', ()=>{ 
	// Clear rule selection if the currently selected rule is not available for the new player count
	if(selectedRuleId) {
		const p = +playersSel.value;
		const availableRules = RULES.filter(r => r.players.includes(p));
		if(!availableRules.find(r => r.id === selectedRuleId)) {
			selectedRuleId = null;
		}
	}
	rebuildRuleList(); rebuildAssignmentsUI(); 
	updatePlayerAssignmentsFromConfig(); // Load saved config for this player count
	rebuildAssignmentsUI(); // Rebuild again with the loaded config
	redrawWithSelection(); 
});

// ===== Bootstrap =====
buildPalettes();
loadDefaultGame(); // Load the default game setup
rebuildRuleList();
rebuildAssignmentsUI(); // This will now pick up the loaded configurations
redrawWithSelection();

</script>
</body>
</html>
