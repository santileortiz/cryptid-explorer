<!doctype html>
<html lang="en">
<head>
	<meta charset="utf-8" />
	<meta name="viewport" content="width=device-width, initial-scale=1" />
	<title>Cryptid Board Analyzer (Lightweight)</title>
	<style>
		:root { --pad: 10px; --bg: #0f172a; --panel: #111827; --muted: #94a3b8; --text: #e5e7eb; }
		html, body { height: 100%; overflow: hidden; }
		body {
			margin: 0; font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
			background: var(--bg); color: var(--text); display: grid; grid-template-columns: 320px 1fr 480px;
			grid-template-rows: auto 1fr; grid-template-areas:
				"header header header"
				"left canvas right";
			gap: 10px; padding: var(--pad);
			box-sizing: border-box;
		}
		h1 { font-size: 18px; margin: 0; letter-spacing: .2px; }
		#header { grid-area: header; display:flex; align-items:center; gap:12px; background:var(--panel); border-radius:12px; padding:10px 14px; }
		.badge { font-size: 12px; color: var(--bg); background: #a7f3d0; border-radius: 999px; padding: 2px 8px; }
		.panel { background: var(--panel); border-radius: 12px; padding: 10px; }
		#left { grid-area: left; display: grid; gap: 10px; align-content: start; }
		#right { grid-area: right; display: grid; gap: 8px; align-content: start; }
		#canvasWrap { grid-area: canvas; position: relative; background: #0b1220; border-radius: 12px; overflow: hidden; }
		label { font-size: 12px; color: var(--muted); }
		select, button, input[type="number"], textarea, input[type="text"] { width: 100%; box-sizing: border-box; background: #0b1220; color: var(--text); border: 1px solid #243041; border-radius: 8px; padding: 8px; font: inherit; }
		button { cursor: pointer; }
		button.inline { width: auto; padding: 6px 10px; border-radius: 8px; }
		.group { display: grid; gap: 6px; }
		.row { display:flex; gap:8px; align-items:center; flex-wrap: wrap; }
		.small { font-size: 12px; color: var(--muted); }
		.kbd { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; background:#0b1220; border:1px solid #223048; padding:2px 6px; border-radius:6px; }
		legend { font-size: 12px; color: var(--muted); margin-bottom: 6px; }
		.ruleList { display:grid; gap:6px; max-height: 25vh; overflow:auto; border:1px solid #223048; border-radius:8px; padding:8px; }
		.ruleItem { display:grid; grid-template-columns: 1fr 42px; gap:6px; align-items:center; }
		#hexsvg { width:100%; height:100%; display:block; }
		#canvasWrap, #hexsvg, #hexsvg * { -webkit-user-select: none; user-select: none; }
		#legend { display:grid; grid-template-columns: repeat(5, minmax(0,1fr)); gap:6px; }
		.swatch { display:flex; gap:6px; align-items:center; background:#0b1220; border:1px solid #243041; border-radius:8px; padding:6px; justify-content:center; }
		.sw { width:14px; height:14px; border-radius:3px; border:1px solid #0007; }
		ul.flat { list-style:none; padding:0; margin:0; display:flex; gap:8px; flex-wrap:wrap; }
		ul.flat li { padding:4px 8px; border:1px solid #223048; border-radius:8px; background:#0b1220; font-size:12px; }
		textarea.code { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace; height: 160px; }
		hr { border:0; border-top:1px solid #223048; margin:8px 0; }
		.colorChip { width:14px; height:14px; border-radius:999px; display:inline-block; vertical-align:middle; border:1px solid #0007; }
		.eye-toggle { width: 20px; height: 20px; padding: 2px; border: 1px solid #243041; background: #0b1220; border-radius: 4px; cursor: pointer; display: inline-flex; align-items: center; justify-content: center; }
		.eye-toggle:hover { background: #1e293b; }
		.eye-toggle svg { width: 14px; height: 14px; fill: var(--muted); }
	</style>
</head>
<body>
	<header id="header" class="panel">
		<h1>Cryptid Explorer</h1>
	</header>

	<section id="left">
		<div class="panel group">
			<label for="players">Players</label>
			<select id="players">
				<option value="3">3 players</option>
				<option value="4" selected>4 players</option>
				<option value="5">5 players</option>
			</select>
			<div class="row">
				<input type="checkbox" id="showHabitat">
				<label for="showHabitat" style="margin-left: 6px; font-size: 14px;">Show Habitat</label>
			</div>
		</div>

		<div class="panel group">
			<div class="small">Click a structure type, then click hexes to place/move/remove structures.</div>
			<div id="structurePalette" style="display: grid; grid-template-columns: 1fr 1fr; gap: 4px;"></div>
		</div>

		<div class="panel group">
			<legend>Tile arrangement</legend>
			<input id="arrangementStr" type="text" placeholder="e.g., 6 3 1 5 4 2" value="-4 -2 -5 1 -3 6">
			<div class="row">
				<button id="applyArrangement" class="inline">Apply</button>
				<button id="toggleTileLabels" class="inline">Toggle tile numbers</button>
			</div>

			<div class="row">
				<button id="prevGame" class="inline">Previous Game</button>
				<button id="nextGame" class="inline">Next Game</button>
			</div>
			
		</div>

		<div class="panel group">
			<legend>Save Game</legend>
			<div class="row">
				<button id="exportGame" class="inline">Export</button>
				<button id="importGame" class="inline">Import</button>
				<button id="toggleCaptureMode" class="inline">Capture Mode</button>
			</div>
			<div id="capturePanel" style="display: none;">
				<div class="small" style="margin-bottom: 8px;">Game Capture: Enter all player configurations for one game, use Tab to navigate</div>
				<div style="display: grid; grid-template-columns: auto 1fr; gap: 6px; margin-bottom: 8px;">
					<label class="small" style="padding: 6px 0; font-weight: bold;">3P:</label>
					<input id="capture3P" type="text" placeholder="G68 O5 P79 51" style="font-family: monospace; padding: 6px; border: 1px solid #666; background: #1f2937; color: white;">
					
					<label class="small" style="padding: 6px 0; font-weight: bold;">4P:</label>
					<input id="capture4P" type="text" placeholder="G62 B1 O78 P65 48" style="font-family: monospace; padding: 6px; border: 1px solid #666; background: #1f2937; color: white;">
					
					<label class="small" style="padding: 6px 0; font-weight: bold;">5P:</label>
					<input id="capture5P" type="text" placeholder="R91 G87 B88 O63 P49 68" style="font-family: monospace; padding: 6px; border: 1px solid #666; background: #1f2937; color: white;">
				</div>
				<div class="row" style="margin-bottom: 6px;">
					<span id="captureStatus" class="small">Queue: 0 games</span>
					<button id="captureGame" class="inline">Capture Game</button>
					<button id="exportQueue" class="inline">Export Queue</button>
					<button id="clearQueue" class="inline">Clear</button>
				</div>
				<div class="small" style="color: #9ca3af;">Colors: R=Red, G=Green, B=Blue, O=Orange, P=Purple | Format: [Color][Clue#] [Color][Clue#] ... [Hint#]</div>
			</div>
			<textarea id="gameJSON" class="code" placeholder="Game JSON will appear here..."></textarea>
		</div>
	</section>

	<main id="canvasWrap">
		<svg id="hexsvg" viewBox="0 0 1000 1000" role="img" aria-label="Cryptid board"></svg>
	</main>

	<aside id="right">
		<div class="panel group">
			<div class="ruleList" id="ruleList"></div>
		</div>

		<div class="panel group">
			<div id="assignments"></div>
			<div style="margin-top: 8px">
				<div style="border-top: 1px solid #223048; margin-bottom: 18px;"></div>
				<div style="font-size: 12px; color: var(--muted); margin-bottom: 6px;">Game Hint</div>
				<div id="hintDisplay"></div>
			</div>
		</div>

		<div class="panel group" id="balanceAnalysis" style="display: none;">
			<legend>2-Player Variant Pairings</legend>
			<div id="balanceResults"></div>
		</div>
	</aside>

<script>
// ===== Core data =====
const TERRAIN = /** @type {const} */ (['desert','swamp','mountain','forest','water']);
const ANIMALS = /** @type {const} */ (['bear','cougar']);
const STRUCT_TYPES = /** @type {const} */ (['standing_stone','abandoned_shack']);
const COLORS = /** @type {const} */ (['black','blue','green','white']);

const TERRAIN_COLORS = { desert:'#F1CC33', swamp:'#361D3f', mountain:'#989898', forest:'#579A4D', water:'#0073CF' };
const STRUCT_COLORS = { black:'#111827', blue:'#3b82f6', green:'#22c55e', white:'#e5e7eb' };
const RULE_COLORS = ['#f97316','#22d3ee','#a78bfa','#34d399','#f43f5e','#eab308','#06b6d4','#84cc16'];

const PLAYER_COLORS = { blue:'#1520A6', red:'#ff0033', green:'#006400', purple:'#9933ff', orange:'#ff6600' };
const PLAYER_COLOR_ORDER = ['blue','red','green','purple','orange'];
const DEFAULT_PLAYER_COLORS_BY_COUNT = {3:['blue','red','green'],4:['blue','red','green','purple'],5:['blue','red','green','purple','orange']};
let PLAYER_ASSIGNMENTS = []; // [{color:'blue'|'red'|'green'|'purple'|'orange', ruleId:string|null, clueNumber:number|null}]

// Game configurations for different player counts
let GAME_CONFIGURATIONS = {
	3: [],  // Array of {color, clueNumber}
	4: [],  // Array of {color, clueNumber} 
	5: []   // Array of {color, clueNumber}
};

// Game hints for different player counts
let GAME_HINTS = {
	3: null,  // Hint number (1-80)
	4: null,  // Hint number (1-80) 
	5: null   // Hint number (1-80)
};

// Batch capture mode
let CAPTURE_MODE = false;
let CAPTURE_QUEUE = [];

// Hint descriptions (1-indexed)
const HINT_DESCRIPTIONS = [
	"", // 0 - placeholder since hints are 1-indexed
	"no within two spaces clues",
	"no within three spaces clues", 
	"no within two spaces clues",
	"no clues that mention any animal territory",
	"no within three spaces clues",
	"no within two spaces clues",
	"no terrain or terrain clues",
	"no within one space clues",
	"no within three spaces clues",
	"no clues that mention desert",
	"no clues that mention forest",
	"no within two spaces clues",
	"no within two spaces clues",
	"no within two spaces clues",
	"no within three spaces clues",
	"no within one space clues",
	"no within two spaces clues",
	"no clues that mention mountain",
	"no clues that mention swamp",
	"no within three spaces clues",
	"no within one space clues",
	"no clues that mention mountain",
	"no within three spaces clues",
	"no within one space clues",
	"no within two spaces clues",
	"no within one space clues",
	"no clues that mention forest",
	"no within one space clues",
	"no within three spaces clues",
	"no clues that mention water",
	"no clues that mention swamp",
	"no terrain or terrain clues",
	"no within one space clues",
	"no within two spaces clues",
	"no within one space clues",
	"no terrain or terrain clues",
	"no within one space clues",
	"no within three spaces clues",
	"no clues that mention water",
	"no within three spaces clues",
	"no within three spaces clues",
	"no within two spaces clues",
	"no within three spaces clues",
	"no within three spaces clues",
	"no within one space clues",
	"no clues that mention water",
	"no within two spaces clues",
	"no within two spaces clues",
	"no terrain or terrain clues",
	"no within two spaces clues",
	"no within two spaces clues",
	"no clues that mention any type of terrain",
	"no within two spaces clues",
	"no within three spaces clues",
	"no within one space clues",
	"no within three spaces clues",
	"no clues that mention desert",
	"no within three spaces clues",
	"no terrain or terrain clues",
	"no within two spaces clues",
	"no within two spaces clues",
	"no within two spaces clues",
	"no clues that mention forest",
	"no within two spaces clues",
	"no within two spaces clues",
	"no within three spaces clues",
	"no within two spaces clues",
	"no clues that mention swamp",
	"no clues that mention mountain",
	"no within three spaces clues",
	"no clues that mention desert",
	"no within two spaces clues",
	"no within three spaces clues",
	"no within three spaces clues",
	"no within three spaces clues",
	"no within one space clues",
	"no within two spaces clues",
	"no within two spaces clues",
	"no within three spaces clues",
	"no terrain or terrain clues"
];

let GAMES = null;

async function loadJsonFile(url)
{
	const response = await fetch(url);
	if (!response.ok)
	{
		throw new Error(`Failed to load ${url}: ${response.status}`);
	}
	return await response.json();
}

loadJsonFile("games.json")
	.then(data => {
		GAMES = data;
	})
	.catch(err => console.error(err));

// Clue book mappings (1-indexed in definition, 0-indexed for JS arrays)
const CLUE_BOOK_MAPPINGS = {
	A_Red: [47, 33, 38, 9, 7, 23, 3, 6, 32, 31, 21, 37, 44, 16, 5, 12, 48, 42, 39, 43, 46, 3, 24, 22, 27, 40, 27, 39, 29, 37, 41, 6, 43, 26, 8, 42, 14, 4, 23, 8, 22, 44, 11, 34, 1, 45, 10, 48, 12, 36, 2, 38, 20, 30, 45, 25, 28, 15, 17, 10, 26, 19, 1, 5, 35, 25, 11, 30, 35, 21, 9, 32, 7, 13, 4, 20, 28, 13, 14, 29, 18, 2, 46, 36, 40, 16, 18, 31, 15, 17, 47, 33, 41, 24, 34, 19],
	B_Green: [26, 48, 42, 6, 43, 35, 2, 30, 10, 17, 46, 11, 31, 20, 12, 47, 40, 8, 38, 17, 15, 41, 19, 4, 39, 5, 23, 29, 32, 24, 21, 34, 27, 42, 45, 33, 6, 10, 22, 14, 1, 37, 47, 12, 43, 36, 25, 23, 38, 3, 13, 22, 46, 39, 11, 2, 1, 41, 13, 18, 40, 31, 3, 44, 45, 48, 36, 16, 18, 4, 37, 5, 26, 33, 8, 28, 27, 20, 44, 35, 14, 28, 29, 9, 16, 34, 7, 24, 25, 30, 9, 32, 7, 21, 19, 15],
	C_Blue: [42, 40, 9, 30, 3, 42, 11, 6, 7, 21, 43, 45, 31, 17, 6, 21, 14, 25, 2, 26, 28, 4, 38, 15, 41, 18, 37, 44, 36, 20, 34, 32, 2, 19, 43, 37, 3, 23, 33, 44, 33, 18, 29, 47, 15, 13, 41, 26, 48, 48, 8, 23, 36, 47, 5, 10, 9, 12, 7, 1, 4, 16, 45, 8, 46, 10, 14, 35, 24, 34, 46, 19, 40, 28, 12, 13, 29, 22, 5, 25, 35, 16, 22, 39, 27, 24, 31, 17, 30, 1, 20, 27, 38, 39, 11, 32],
	D_Orange: [8, 47, 24, 38, 1, 17, 28, 7, 23, 16, 27, 2, 47, 39, 43, 21, 46, 21, 29, 40, 11, 41, 9, 33, 32, 35, 26, 4, 41, 37, 8, 18, 3, 25, 34, 44, 9, 22, 30, 32, 10, 39, 42, 14, 45, 35, 38, 20, 45, 31, 26, 46, 33, 5, 18, 44, 10, 36, 30, 6, 16, 12, 48, 23, 7, 17, 11, 22, 34, 19, 6, 48, 42, 29, 5, 3, 37, 27, 13, 4, 25, 12, 36, 40, 43, 31, 15, 14, 19, 20, 28, 13, 1, 15, 24, 2],
	E_Purple: [30, 37, 12, 5, 6, 18, 41, 27, 43, 22, 35, 23, 36, 14, 12, 44, 40, 11, 41, 4, 48, 40, 48, 2, 4, 29, 31, 43, 39, 45, 10, 1, 32, 38, 24, 3, 31, 32, 10, 5, 42, 37, 20, 33, 25, 3, 2, 30, 14, 42, 29, 44, 15, 8, 26, 23, 39, 16, 22, 21, 46, 25, 20, 16, 19, 34, 35, 38, 8, 17, 7, 28, 17, 19, 18, 26, 6, 27, 15, 9, 13, 46, 45, 33, 24, 47, 28, 9, 47, 1, 13, 36, 7, 21, 34, 11]
};

// Map color to clue book
const COLOR_TO_CLUE_BOOK = {
	red: 'A_Red',
	green: 'B_Green',
	blue: 'C_Blue',
	orange: 'D_Orange',
	purple: 'E_Purple'
};

function resolveRuleFromClue(color, clueNumber) {
	const bookKey = COLOR_TO_CLUE_BOOK[color];
	if (!bookKey || !CLUE_BOOK_MAPPINGS[bookKey]) return null;
	
	const mapping = CLUE_BOOK_MAPPINGS[bookKey];
	if (clueNumber < 1 || clueNumber > 96) return null;
	
	const ruleIndex = mapping[clueNumber - 1]; // Convert 1-indexed to 0-indexed
	const rule = RULES.find(r => r.id === String(ruleIndex));
	
	
	return rule ? rule.id : null;
}

const ANIMAL_GLYPH = { bear:'üêª', cougar:'üêæ' };

// ===== Types =====
/** @typedef {('desert'|'swamp'|'mountain'|'forest'|'water')} Terrain */
/** @typedef {('bear'|'cougar')} Animal */
/** @typedef {('standing_stone'|'abandoned_shack')} StructureType */
/** @typedef {('black'|'blue'|'green'|'white')} Color */
/** @typedef {{ q:number, r:number, terrain:Terrain, animals:Set<Animal>, structures:Array<{type:StructureType,color:Color}> }} Cell */

// ===== Board =====
const Board = { width:12, height:9, cells:new Map() };
const key = (q,r)=>`${q},${r}`;
function forEachCell(cb){ for(const c of Board.cells.values()) cb(c); }
function cellAt(q,r){ let c=Board.cells.get(key(q,r)); if(!c){ c={q,r,terrain:'water',animals:new Set(),structures:[]}; Board.cells.set(key(q,r),c);} return c; }
function hexDist(a,b){
	// Correct odd-q (vertical columns) distance via cube coords
	function toCube(q,r){
		const x = q;
		const z = r - ((q - (q & 1)) / 2);
		const y = -x - z;
		return {x,y,z};
	}
	const ac = toCube(a.q,a.r);
	const bc = toCube(b.q,b.r);
	const dx = Math.abs(ac.x - bc.x);
	const dy = Math.abs(ac.y - bc.y);
	const dz = Math.abs(ac.z - bc.z);
	return (dx + dy + dz) / 2;
}

// ===== Tiles (2√ó3 grid of 6√ó3 hexes each) =====
const TILE_W = 6, TILE_H = 3;
/** @typedef {{ terrain: Terrain[][], animals: Array<{x:number,y:number, animal:Animal}>, structures: Array<{x:number,y:number, type:StructureType, color:Color}> }} TileDef */

// Default tiles with animals (from your last message)
const DEFAULT_TILES = {
  "1": {"terrain":[["water","water","water","water","forest","forest"],["swamp","swamp","water","desert","forest","forest"],["swamp","swamp","desert","desert","desert","forest"]],"animals":[{"x":3,"y":2,"animal":"bear"},{"x":4,"y":2,"animal":"bear"}],"structures":[]},
  "2": {"terrain":[["swamp","forest","forest","forest","forest","forest"],["swamp","swamp","forest","desert","desert","desert"],["swamp","mountain","mountain","mountain","mountain","desert"]],"animals":[{"x":0,"y":0,"animal":"cougar"},{"x":1,"y":0,"animal":"cougar"},{"x":2,"y":0,"animal":"cougar"}],"structures":[]},
  "3": {"terrain":[["swamp","swamp","forest","forest","forest","water"],["swamp","swamp","forest","mountain","water","water"],["mountain","mountain","mountain","mountain","water","water"]],"animals":[{"x":0,"y":1,"animal":"cougar"},{"x":1,"y":1,"animal":"cougar"},{"x":0,"y":2,"animal":"cougar"}],"structures":[]},
  "4": {"terrain":[["desert","desert","mountain","mountain","mountain","mountain"],["desert","desert","mountain","water","water","water"],["desert","desert","desert","forest","forest","forest"]],"animals":[{"x":5,"y":1,"animal":"cougar"},{"x":5,"y":2,"animal":"cougar"}],"structures":[]},
  "5": {"terrain":[["swamp","swamp","swamp","mountain","mountain","mountain"],["swamp","desert","desert","water","mountain","mountain"],["desert","desert","water","water","water","water"]],"animals":[{"x":5,"y":1,"animal":"bear"},{"x":4,"y":2,"animal":"bear"},{"x":5,"y":2,"animal":"bear"}],"structures":[]},
  "6": {"terrain":[["desert","desert","swamp","swamp","swamp","forest"],["mountain","mountain","swamp","swamp","forest","forest"],["mountain","water","water","water","water","forest"]],"animals":[{"x":0,"y":0,"animal":"bear"},{"x":0,"y":1,"animal":"bear"}],"structures":[]}
};
/** @type {Record<number, TileDef>} */
let TILES = structuredClone(DEFAULT_TILES);
let lastArrangement = null; // Array<{id:number, flipped:boolean, col:number, row:number}>
let showTileLabels = true;

// ===== Geometry: FLAT-TOP, odd-q offset =====
const svg = document.getElementById('hexsvg');
svg.addEventListener('mousedown', (e)=>{ if(e.shiftKey) e.preventDefault(); });
const svgNS = 'http://www.w3.org/2000/svg';
let HEX_SIZE = 26;
function hexToPoint(q,r){
	const x = 1.5 * HEX_SIZE * q;
	const y = Math.sqrt(3) * HEX_SIZE * (r + ((q & 1) ? 0.5 : 0));
	return {x,y};
}
function polygonPoints(cx,cy,size){
	const pts=[];
	for(let i=0;i<6;i++){
		const ang = Math.PI/180 * (60*i);
		pts.push([cx + size*Math.cos(ang), cy + size*Math.sin(ang)]);
	}
	return pts.map(([x,y])=>x.toFixed(2)+","+y.toFixed(2)).join(' ');
}
function regularPolygonPoints(cx, cy, radius, sides, rotationDeg=0){
	const pts=[]; const rot = Math.PI/180 * rotationDeg;
	for(let i=0;i<sides;i++){
		const ang = rot + i * (2*Math.PI/sides);
		pts.push([cx + radius*Math.cos(ang), cy + radius*Math.sin(ang)]);
	}
	return pts.map(([x,y])=>x.toFixed(2)+","+y.toFixed(2)).join(' ');
}

function draw(perRuleOverlays, uniqueKey, selectedRuleOverlay, showHabitat = true, habitatCells = null){
	svg.innerHTML='';
	// tight viewBox
	const Rx = HEX_SIZE, Ry = Math.sqrt(3)*HEX_SIZE/2;
	let minX=Infinity, minY=Infinity, maxX=-Infinity, maxY=-Infinity;
	const centers=new Map();
	forEachCell(c=>{ const p=hexToPoint(c.q,c.r); centers.set(key(c.q,c.r),p);
		minX=Math.min(minX,p.x-Rx); maxX=Math.max(maxX,p.x+Rx);
		minY=Math.min(minY,p.y-Ry); maxY=Math.max(maxY,p.y+Ry); });
	const pad=HEX_SIZE*1.2; svg.setAttribute('viewBox', `${minX-pad} ${minY-pad} ${maxX-minX+pad*2} ${maxY-minY+pad*2}`);

	forEachCell(c=>{
		const {x,y}=centers.get(key(c.q,c.r));
		const g=document.createElementNS(svgNS,'g'); g.setAttribute('transform',`translate(${x},${y})`); g.dataset.q=String(c.q); g.dataset.r=String(c.r);
		// base
		const poly=document.createElementNS(svgNS,'polygon'); poly.setAttribute('points', polygonPoints(0,0,HEX_SIZE)); poly.setAttribute('fill',TERRAIN_COLORS[c.terrain]); poly.setAttribute('stroke','#0b1220'); poly.setAttribute('stroke-width','1'); g.appendChild(poly);
		// animals
		if(c.animals.size){ const t=document.createElementNS(svgNS,'text'); t.setAttribute('x','0'); t.setAttribute('y','-6'); t.setAttribute('text-anchor','middle'); t.setAttribute('font-size','16'); t.setAttribute('font-weight','700'); t.textContent=[...c.animals].map(a=>ANIMAL_GLYPH[a]).join(''); g.appendChild(t); }
		// structures
		if(c.structures.length){
			const sG=document.createElementNS(svgNS,'g');
			sG.setAttribute('transform','translate(0,0)'); // Center structures
			c.structures.slice(0,3).forEach((s,i)=>{
				const dx = c.structures.length === 1 ? 0 : (-12 + i*12); // Center single structures, spread multiple
				if(s.type==='standing_stone'){
					const p=document.createElementNS(svgNS,'polygon');
					p.setAttribute('points', regularPolygonPoints(dx,0,9,8,22.5)); // Increased from 5.5 to 9
					p.setAttribute('fill', STRUCT_COLORS[s.color]);
					p.setAttribute('stroke', '#e5e7eb'); p.setAttribute('stroke-width','0.75');
					sG.appendChild(p);
				} else {
					const p=document.createElementNS(svgNS,'polygon');
					p.setAttribute('points', regularPolygonPoints(dx,0,10,3,-90)); // Increased from 6 to 10
					p.setAttribute('fill', STRUCT_COLORS[s.color]);
					p.setAttribute('stroke', '#e5e7eb'); p.setAttribute('stroke-width','0.75');
					sG.appendChild(p);
				}
			});
			g.appendChild(sG);
		}
		// per-rule outlines (use player colors if provided) - circular outlines for better readability
		if(Array.isArray(perRuleOverlays)){
			perRuleOverlays.forEach((ov,i)=>{ if(ov.set.has(key(c.q,c.r))){ const inset=6+i*3; const hl=document.createElementNS(svgNS,'circle'); hl.setAttribute('r', Math.max(HEX_SIZE-inset,8)); hl.setAttribute('fill','none'); hl.setAttribute('stroke', ov.color || RULE_COLORS[i%RULE_COLORS.length]); hl.setAttribute('stroke-width','3'); g.appendChild(hl);} });
		}
		
		// selected rule overlay (black circular outline with smallest radius, drawn last so it's on top)
		if(selectedRuleOverlay && selectedRuleOverlay.set.has(key(c.q,c.r))){
			const maxInset = 6 + (perRuleOverlays ? perRuleOverlays.length * 3 : 0);
			const hl=document.createElementNS(svgNS,'circle'); 
			hl.setAttribute('r', Math.max(HEX_SIZE-maxInset-3,6)); 
			hl.setAttribute('fill','none'); 
			hl.setAttribute('stroke','#000000'); 
			hl.setAttribute('stroke-width','2'); 
			g.appendChild(hl);
		}
		
		// habitat cells (show target emoji for all cells in final intersection)
		if(habitatCells && habitatCells.has(key(c.q,c.r)) && showHabitat){
			const habitat=document.createElementNS(svgNS,'text'); 
			habitat.setAttribute('x','0'); 
			habitat.setAttribute('y','4'); 
			habitat.setAttribute('text-anchor','middle'); 
			habitat.setAttribute('font-size','20'); 
			habitat.setAttribute('font-weight','700');
			habitat.setAttribute('fill','#fbbf24');
			habitat.setAttribute('stroke','#000000');
			habitat.setAttribute('stroke-width','1');
			habitat.style.paintOrder='stroke';
			habitat.textContent='üéØ'; 
			g.appendChild(habitat);
		}
		g.addEventListener('click', onHexClick); svg.appendChild(g);
	});

	// tile number labels
	if(showTileLabels && Array.isArray(lastArrangement)){
		lastArrangement.forEach(arr=>{
			const q0 = arr.col * TILE_W, r0 = arr.row * TILE_H;
			const corner = arr.flipped ? hexToPoint(q0 + TILE_W - 1, r0 + TILE_H - 1) : hexToPoint(q0, r0);
			const tx = arr.flipped ? corner.x + HEX_SIZE * 0.7 : corner.x - HEX_SIZE * 0.7;
			const ty = arr.flipped ? corner.y + HEX_SIZE * 0.7 : corner.y - HEX_SIZE * 0.7;
			const t = document.createElementNS(svgNS,'text');
			t.setAttribute('x', String(tx)); t.setAttribute('y', String(ty));
			t.setAttribute('text-anchor', arr.flipped ? 'end' : 'start');
			t.setAttribute('dominant-baseline', arr.flipped ? 'ideographic' : 'hanging');
			t.setAttribute('font-size','18'); t.setAttribute('font-weight','800');
			t.setAttribute('fill','#f8fafc'); t.setAttribute('stroke','#000'); t.setAttribute('stroke-width','3'); t.style.paintOrder='stroke';
			t.textContent = String(arr.id);
			svg.appendChild(t);
		});
	}
}

let habitatCellSet = null; // Global variable to store habitat cells

function redrawWithSelection(){
	let selectedRuleOverlay = null;
	if(selectedRuleId){
		const rule = RULES.find(r => r.id === selectedRuleId);
		if(rule){
			const validCells = evalRule(rule);
			selectedRuleOverlay = { set: validCells };
		}
	}
	const showHabitat = document.getElementById('showHabitat')?.checked ?? true;
	draw(latestPerRule, latestUniqueKey, selectedRuleOverlay, showHabitat, habitatCellSet);
	updateRuleCounts();
}

// ===== Structure placement variables =====
let currentStructureType = null; // 'standing_stone' | 'abandoned_shack' | null
let currentStructureColor = null; // 'black' | 'blue' | 'green' | 'white' | null

// ===== Auto-advance structure selection =====
function advanceToNextStructure() {
	// Order: blue stone -> blue shack -> green stone -> green shack -> white stone -> white shack -> black stone -> black shack
	const structureSequence = [
		{ color: 'blue', type: 'standing_stone' },
		{ color: 'blue', type: 'abandoned_shack' },
		{ color: 'green', type: 'standing_stone' },
		{ color: 'green', type: 'abandoned_shack' },
		{ color: 'white', type: 'standing_stone' },
		{ color: 'white', type: 'abandoned_shack' },
		{ color: 'black', type: 'standing_stone' },
		{ color: 'black', type: 'abandoned_shack' }
	];
	
	// Find current position in sequence
	const currentIndex = structureSequence.findIndex(s => 
		s.color === currentStructureColor && s.type === currentStructureType
	);
	
	// Advance to next in sequence (wrap around to beginning)
	const nextIndex = currentIndex === -1 ? 0 : (currentIndex + 1) % structureSequence.length;
	const nextStructure = structureSequence[nextIndex];
	
	currentStructureColor = nextStructure.color;
	currentStructureType = nextStructure.type;
	
	// Update visual selection in structure palette
	document.querySelectorAll('#structurePalette button').forEach(b => {
		b.style.boxShadow = '';
	});
	
	// Find and highlight the new selection
	// Structure palette layout: blue stone, blue shack, green stone, green shack, white stone, white shack, black stone, black shack
	const buttons = document.querySelectorAll('#structurePalette button');
	if (buttons[nextIndex]) {
		buttons[nextIndex].style.boxShadow = '0 0 0 2px #22d3ee';
	}
}

// ===== Hex click (structure placement only) =====
function onHexClick(e){
	e.preventDefault(); e.stopPropagation();
	if(!currentStructureType || !currentStructureColor) return;
	
	const q = +this.dataset.q, r = +this.dataset.r;
	const c = cellAt(q, r);
	
	// Check if there's an existing structure in this cell
	const existingStructure = c.structures.length > 0 ? c.structures[0] : null;
	
	if(existingStructure){
		// If same type and color as selected, remove it
		if(existingStructure.type === currentStructureType && existingStructure.color === currentStructureColor){
			c.structures = [];
		} else {
			// Different structure - replace it, but first check for uniqueness constraint
			// Remove any existing structure of the same type and color from the board
			forEachCell(otherCell => {
				otherCell.structures = otherCell.structures.filter(s => 
					!(s.type === currentStructureType && s.color === currentStructureColor)
				);
			});
			// Place the new structure
			c.structures = [{type: currentStructureType, color: currentStructureColor}];
		}
	} else {
		// No existing structure - add new one, but enforce uniqueness constraint
		// Remove any existing structure of the same type and color from the board
		forEachCell(otherCell => {
			otherCell.structures = otherCell.structures.filter(s => 
				!(s.type === currentStructureType && s.color === currentStructureColor)
			);
		});
		// Place the new structure
		c.structures = [{type: currentStructureType, color: currentStructureColor}];
	}
	
	autoEvaluateAndRedraw();
	
	// Auto-advance to next structure if in capture mode
	if (CAPTURE_MODE) {
		advanceToNextStructure();
	}
}


// ===== Tile helpers =====
function blankBoard(){
	Board.cells.clear();
	for(let r=0;r<Board.height;r++){
		for(let q=0;q<Board.width;q++){
			const c=cellAt(q,r); c.terrain='water'; c.animals.clear(); c.structures=[];
		}
	}
}
function mapXY(x,y, flipped){ return flipped ? {x:TILE_W-1-x, y:TILE_H-1-y} : {x,y}; }
function stampTile(tileId, flipped, col, row){
	const def = TILES[Number(tileId)]; if(!def) return;
	const q0 = col * TILE_W, r0 = row * TILE_H;
	for(let y=0;y<TILE_H;y++){
		for(let x=0;x<TILE_W;x++){
			const m = mapXY(x,y, flipped);
			const c = cellAt(q0+x, r0+y);
			c.terrain = def.terrain[m.y][m.x];
			c.animals.clear(); c.structures=[];
		}
	}
	(def.animals||[]).forEach(a=>{ const m=mapXY(a.x,a.y,flipped); cellAt(q0+m.x, r0+m.y).animals.add(a.animal); });
	(def.structures||[]).forEach(s=>{ const m=mapXY(s.x,s.y,flipped); cellAt(q0+m.x, r0+m.y).structures.push({type:s.type, color:s.color}); });
}
function parseArrangement(str){
	const nums = (str.match(/[+-]?[0-9]+/g)||[]).map(n=>parseInt(n,10));
	if(nums.length!==6) throw new Error('Provide six signed integers 1..6');
	const abs = nums.map(n=>Math.abs(n));
	if(abs.some(n=>n<1||n>6)) throw new Error('Tile ids must be 1..6');
	const uniq = new Set(abs); if(uniq.size!==6) throw new Error('Tile ids must not repeat');
	return nums.map((n,i)=>({ id:Math.abs(n), flipped:n<0, col:i%2, row:Math.floor(i/2) }));
}
function applyArrangementString(str, redraw=true){
	try{
		const arr = parseArrangement(str);
		lastArrangement = arr;
		blankBoard();
		arr.forEach(a=> stampTile(a.id, a.flipped, a.col, a.row));
		if(redraw){ autoEvaluateAndRedraw(); }
	}catch(e){ alert(e.message); }
}

// ===== Import/Export (game) =====
const exportBtn=document.getElementById('exportGame');
const importBtn=document.getElementById('importGame');
const gameJSON=document.getElementById('gameJSON');

function exportGame() {
	// Get current tile arrangement
	const arrangementStr = document.getElementById('arrangementStr').value || "1 2 3 4 5 6";
	
	// Get all structures from the board
	const structures = [];
	forEachCell(c => {
		if (c.structures.length > 0) {
			c.structures.forEach(s => {
				structures.push({
					type: s.type,
					color: s.color,
					q: c.q,
					r: c.r
				});
			});
		}
	});
	
	// Create game data
	const gameData = {
		tileArrangement: arrangementStr,
		structures: structures,
		playerConfigs: {
			3: GAME_CONFIGURATIONS[3],
			4: GAME_CONFIGURATIONS[4], 
			5: GAME_CONFIGURATIONS[5]
		},
		hints: {
			3: GAME_HINTS[3],
			4: GAME_HINTS[4],
			5: GAME_HINTS[5]
		}
	};
	
	gameJSON.value = JSON.stringify(gameData, null, 2);
}

function loadGame(gameData) {
	// Apply tile arrangement
	document.getElementById('arrangementStr').value = gameData.tileArrangement || "1 2 3 4 5 6";
	applyArrangementString(gameData.tileArrangement || "1 2 3 4 5 6", false);

	// Place structures
	if (gameData.structures) {
		gameData.structures.forEach(s => {
			const cell = cellAt(s.q, s.r);
			cell.structures.push({
					     type: s.type,
					     color: s.color
			});
		});
	}

	// Load player configurations
	if (gameData.playerConfigs) {
		GAME_CONFIGURATIONS[3] = gameData.playerConfigs[3] || [];
		GAME_CONFIGURATIONS[4] = gameData.playerConfigs[4] || [];
		GAME_CONFIGURATIONS[5] = gameData.playerConfigs[5] || [];
	}

	// Load hints
	if (gameData.hints) {
		GAME_HINTS[3] = gameData.hints[3] || null;
		GAME_HINTS[4] = gameData.hints[4] || null;
		GAME_HINTS[5] = gameData.hints[5] || null;
	}

	// Update current player assignments based on current player count
	updatePlayerAssignmentsFromConfig();

	rebuildAssignmentsUI();
	updateHintDisplay(); // Update hint display after import
	autoEvaluateAndRedraw();
}

function importGame() {
	try {
		loadGame (JSON.parse(gameJSON.value));
	} catch(e) { 
		alert('Invalid Game JSON: ' + e.message); 
	}
}

let currentGame = 0;

const prevGameBtn = document.getElementById('prevGame');
prevGameBtn.addEventListener('click', prevGame);
const nextGameBtn = document.getElementById('nextGame');
nextGameBtn.addEventListener('click', nextGame);

function nextGame() {
	try {
		currentGame++;
		currentGame = currentGame % GAMES.length;
		loadGame(GAMES[currentGame]);
	} catch(e) { 
		alert('Invalid Game JSON: ' + e.message); 
	}
}

function prevGame() {
	try {
		currentGame--;
		currentGame = currentGame < 0 ? GAMES.length -1 : currentGame;
		loadGame (GAMES[currentGame]);
	} catch(e) { 
		alert('Invalid Game JSON: ' + e.message); 
	}
}

function updatePlayerAssignmentsFromConfig() {
	const p = +playersSel.value;
	const config = GAME_CONFIGURATIONS[p] || [];
	const defaultColors = DEFAULT_PLAYER_COLORS_BY_COUNT[p] || PLAYER_COLOR_ORDER.slice(0,p);
	
	// Ensure PLAYER_ASSIGNMENTS has the right length
	while(PLAYER_ASSIGNMENTS.length < p) {
		PLAYER_ASSIGNMENTS.push({
			color: defaultColors[PLAYER_ASSIGNMENTS.length] || PLAYER_COLOR_ORDER[PLAYER_ASSIGNMENTS.length],
			ruleId: null,
			clueNumber: null
		});
	}
	PLAYER_ASSIGNMENTS.length = p; // Trim if too long
	
	// Update PLAYER_ASSIGNMENTS with config data
	config.forEach((cfg, i) => {
		if (i < PLAYER_ASSIGNMENTS.length) {
			PLAYER_ASSIGNMENTS[i].color = cfg.color;
			PLAYER_ASSIGNMENTS[i].clueNumber = cfg.clueNumber;
			PLAYER_ASSIGNMENTS[i].ruleId = resolveRuleFromClue(cfg.color, cfg.clueNumber);
		}
	});
}

function saveCurrentAssignmentsToConfig() {
	const p = +playersSel.value;
	GAME_CONFIGURATIONS[p] = PLAYER_ASSIGNMENTS.map(a => ({
		color: a.color,
		clueNumber: a.clueNumber
	})).filter(cfg => cfg.clueNumber !== null);
}

function loadDefaultGame() {
	let default_game = GAMES[0];

	// Apply tile arrangement
	document.getElementById('arrangementStr').value = default_game.tileArrangement;
	applyArrangementString(default_game.tileArrangement, false);
	
	// Place structures
	default_game.structures.forEach(s => {
		const cell = cellAt(s.q, s.r);
		cell.structures.push({
			type: s.type,
			color: s.color
		});
	});
	
	// Load player configurations
	GAME_CONFIGURATIONS[3] = [...default_game.playerConfigs[3]];
	GAME_CONFIGURATIONS[4] = [...default_game.playerConfigs[4]];
	GAME_CONFIGURATIONS[5] = [...default_game.playerConfigs[5]];
	
	// Load hints
	GAME_HINTS[3] = default_game.hints[3];
	GAME_HINTS[4] = default_game.hints[4];
	GAME_HINTS[5] = default_game.hints[5];
	
	// Display the default game JSON in the text area
	gameJSON.value = JSON.stringify(default_game, null, 2);
	
	// Update current player assignments based on current player count
	updatePlayerAssignmentsFromConfig();
}

exportBtn.addEventListener('click', exportGame);
importBtn.addEventListener('click', importGame);

// ===== Batch Capture Mode =====
const toggleCaptureModeBtn = document.getElementById('toggleCaptureMode');
const capturePanel = document.getElementById('capturePanel');
const capture3PInput = document.getElementById('capture3P');
const capture4PInput = document.getElementById('capture4P');
const capture5PInput = document.getElementById('capture5P');
const captureGameBtn = document.getElementById('captureGame');
const captureStatus = document.getElementById('captureStatus');
const exportQueueBtn = document.getElementById('exportQueue');
const clearQueueBtn = document.getElementById('clearQueue');

function toggleCaptureMode() {
	CAPTURE_MODE = !CAPTURE_MODE;
	capturePanel.style.display = CAPTURE_MODE ? 'block' : 'none';
	toggleCaptureModeBtn.textContent = CAPTURE_MODE ? 'Exit Capture' : 'Capture Mode';
	updateCaptureStatus();
	
	if (CAPTURE_MODE) {
		// Focus on tile arrangement and select text for easy replacement
		setTimeout(() => {
			capture3PInput.value = '';
			capture4PInput.value = '';
			capture5PInput.value = '';
			
			const arrangementInput = document.getElementById('arrangementStr');
			arrangementInput.focus();
			arrangementInput.select();
		}, 100);
	}
}

function updateCaptureStatus() {
	captureStatus.textContent = `Queue: ${CAPTURE_QUEUE.length} games`;
}

function checkAutoCapture() {
	if (!CAPTURE_MODE) return;
	
	const p = +playersSel.value;
	const hintNumber = GAME_HINTS[p];
	
	// Check if all players have clues and hint is set
	const allPlayersComplete = PLAYER_ASSIGNMENTS.slice(0, p).every(a => a.clueNumber && a.clueNumber >= 1 && a.clueNumber <= 96);
	const hintComplete = hintNumber && hintNumber >= 1 && hintNumber <= 80;
	
	if (allPlayersComplete && hintComplete) {
		captureCurrentGame();
	}
}

function captureCurrentGame() {
	const gameData = {
		playerCount: +playersSel.value,
		tileArrangement: document.getElementById('arrangementStr').value || "-4 -2 -5 1 -3 6",
		structures: [],
		playerConfigs: PLAYER_ASSIGNMENTS.slice(0, +playersSel.value).map(a => ({
			color: a.color,
			clueNumber: a.clueNumber
		})),
		hint: GAME_HINTS[+playersSel.value]
	};
	
	// Get structures from board
	forEachCell(c => {
		if (c.structures.length > 0) {
			c.structures.forEach(s => {
				gameData.structures.push({
					type: s.type,
					color: s.color,
					q: c.q,
					r: c.r
				});
			});
		}
	});
	
	CAPTURE_QUEUE.push(gameData);
	updateCaptureStatus();
	
	// Show brief success feedback
	const originalText = captureStatus.textContent;
	captureStatus.textContent = `‚úì Game ${CAPTURE_QUEUE.length} captured!`;
	captureStatus.style.color = '#22c55e';
	setTimeout(() => {
		updateCaptureStatus();
		captureStatus.style.color = 'var(--muted)';
	}, 1000);
}

function parsePlayerConfig(inputStr, playerCount) {
	// Format: "G68 O5 P79 H51" (for playerCount clues + hint)
	const trimmed = inputStr.trim().toUpperCase();
	if (!trimmed) return null;
	
	// Parse the clues and hint
	const parts = trimmed.split(/\s+/);
	
	// Should have playerCount clues + 1 hint
	if (parts.length !== playerCount + 1) return null;
	
	// Extract clues
	const colorMap = { R: 'red', G: 'green', B: 'blue', O: 'orange', P: 'purple' };
	const clues = [];
	
	for (let i = 0; i < playerCount; i++) {
		const part = parts[i];
		if (part.length < 2) return null;
		
		const colorLetter = part[0];
		const clueNumber = parseInt(part.substring(1));
		
		if (!colorMap[colorLetter] || isNaN(clueNumber) || clueNumber < 1 || clueNumber > 96) {
			return null;
		}
		
		clues.push({ color: colorMap[colorLetter], clueNumber });
	}
	
	// Extract hint (just a number, no "H" prefix)
	const hintPart = parts[playerCount];
	const hintNumber = parseInt(hintPart);
	if (isNaN(hintNumber) || hintNumber < 1 || hintNumber > 80) return null;
	
	return { clues, hintNumber };
}

function captureCompleteGame() {
	// Parse all three player configurations
	const config3P = parsePlayerConfig(capture3PInput.value, 3);
	const config4P = parsePlayerConfig(capture4PInput.value, 4);
	const config5P = parsePlayerConfig(capture5PInput.value, 5);
	
	// Check if all configurations are valid
	if (!config3P || !config4P || !config5P) {
		// Highlight invalid inputs
		[capture3PInput, capture4PInput, capture5PInput].forEach((input, idx) => {
			const config = [config3P, config4P, config5P][idx];
			if (!config) {
				input.style.borderColor = '#ef4444';
				setTimeout(() => { input.style.borderColor = '#666'; }, 1000);
			}
		});
		return false;
	}
	
	// Create game data with all player configurations
	const gameData = {
		tileArrangement: document.getElementById('arrangementStr').value || "-4 -2 -5 1 -3 6",
		structures: [],
		playerConfigs: {
			3: config3P.clues,
			4: config4P.clues,
			5: config5P.clues
		},
		hints: {
			3: config3P.hintNumber,
			4: config4P.hintNumber,
			5: config5P.hintNumber
		}
	};
	
	// Get structures from board
	forEachCell(c => {
		if (c.structures.length > 0) {
			c.structures.forEach(s => {
				gameData.structures.push({
					type: s.type,
					color: s.color,
					q: c.q,
					r: c.r
				});
			});
		}
	});
	
	// Add to queue
	CAPTURE_QUEUE.push(gameData);
	updateCaptureStatus();
	
	// Show success feedback
	[capture3PInput, capture4PInput, capture5PInput].forEach(input => {
		input.style.borderColor = '#22c55e';
		setTimeout(() => { input.style.borderColor = '#666'; }, 500);
	});
	
	const originalText = captureStatus.textContent;
	captureStatus.textContent = `‚úì Game ${CAPTURE_QUEUE.length} captured!`;
	captureStatus.style.color = '#22c55e';
	setTimeout(() => {
		updateCaptureStatus();
		captureStatus.style.color = 'var(--muted)';
	}, 1000);
	
	// Auto-clear inputs for next game
	setTimeout(() => {
		capture3PInput.value = '';
		capture4PInput.value = '';
		capture5PInput.value = '';
		
		// Focus on tile arrangement and select text for easy replacement
		const arrangementInput = document.getElementById('arrangementStr');
		arrangementInput.focus();
		arrangementInput.select();
		
		// Reset structure selection to first (blue standing stone)
		currentStructureType = 'standing_stone';
		currentStructureColor = 'blue';
		
		// Update structure palette visual selection
		document.querySelectorAll('#structurePalette button').forEach(b => {
			b.style.boxShadow = '';
		});
		
		// Find and highlight the blue standing stone button
		const structurePaletteButtons = document.querySelectorAll('#structurePalette button');
		if (structurePaletteButtons.length > 0) {
			structurePaletteButtons[0].style.boxShadow = '0 0 0 2px #22d3ee';
		}
	}, 600);
	
	return true;
}


function exportQueue() {
	if (CAPTURE_QUEUE.length === 0) {
		alert('No games in queue to export!');
		return;
	}
	
	const queueJSON = JSON.stringify(CAPTURE_QUEUE, null, 2);
	document.getElementById('gameJSON').value = queueJSON;
	
	// Create and download JSON file
	const blob = new Blob([queueJSON], { type: 'application/json' });
	const url = URL.createObjectURL(blob);
	
	const a = document.createElement('a');
	a.href = url;
	a.download = `cryptid-games-${new Date().toISOString().slice(0, 10)}.json`; // e.g., cryptid-games-2024-08-24.json
	document.body.appendChild(a);
	a.click();
	document.body.removeChild(a);
	URL.revokeObjectURL(url);
	
	// Show success feedback
	const originalText = exportQueueBtn.textContent;
	exportQueueBtn.textContent = 'Downloaded!';
	setTimeout(() => {
		exportQueueBtn.textContent = originalText;
	}, 1000);
}

function clearQueue() {
	if (confirm('Clear all captured games from queue?')) {
		CAPTURE_QUEUE = [];
		updateCaptureStatus();
	}
}

toggleCaptureModeBtn.addEventListener('click', toggleCaptureMode);
exportQueueBtn.addEventListener('click', exportQueue);
clearQueueBtn.addEventListener('click', clearQueue);

// Capture input event listeners
const captureInputs = [capture3PInput, capture4PInput, capture5PInput];

captureInputs.forEach((input, index) => {
	// Tab navigation enhancement
	input.addEventListener('keydown', (e) => {
		if (e.key === 'Tab' && !e.shiftKey) {
			// Tab to next field
			e.preventDefault();
			const nextIndex = (index + 1) % captureInputs.length;
			captureInputs[nextIndex].focus();
		} else if (e.key === 'Tab' && e.shiftKey) {
			// Shift+Tab to previous field
			e.preventDefault();
			const prevIndex = (index - 1 + captureInputs.length) % captureInputs.length;
			captureInputs[prevIndex].focus();
		} else if (e.key === 'Enter') {
			// Enter attempts to capture if this is the last field or if all fields are filled
			if (index === 2 || captureInputs.every(inp => inp.value.trim())) {
				captureCompleteGame();
			} else {
				// Move to next field
				const nextIndex = (index + 1) % captureInputs.length;
				captureInputs[nextIndex].focus();
			}
		}
	});
});

// Capture button event listener
captureGameBtn.addEventListener('click', captureCompleteGame);

// Tile arrangement apply and structure placement start in capture mode
document.getElementById('arrangementStr').addEventListener('keydown', (e) => {
	if (CAPTURE_MODE && e.key === 'Enter') {
		e.preventDefault();
		
		// Apply the tile arrangement
		const arrangementInput = document.getElementById('arrangementStr');
		applyArrangementString(arrangementInput.value, true);
		
		// Start structure placement mode by selecting first structure
		currentStructureType = 'standing_stone';
		currentStructureColor = 'blue';
		
		// Update structure palette visual selection
		document.querySelectorAll('#structurePalette button').forEach(b => {
			b.style.boxShadow = '';
		});
		
		// Highlight the blue standing stone button
		const structurePaletteButtons = document.querySelectorAll('#structurePalette button');
		if (structurePaletteButtons.length > 0) {
			structurePaletteButtons[0].style.boxShadow = '0 0 0 2px #22d3ee';
		}
		
		// Remove focus from input so user can start clicking on hex tiles
		arrangementInput.blur();
	}
});

// Quick jump to player configs from structure placement (global key listener in capture mode)
document.addEventListener('keydown', (e) => {
	if (CAPTURE_MODE && e.key === 'Tab' && !e.target.matches('input, textarea')) {
		e.preventDefault();
		capture3PInput.focus();
	}
});

// (Tiles are fixed to the standard 6; no capture/export/import UI)
// ===== Tile UI wires =====
const arrangementStr = document.getElementById('arrangementStr');
const applyArrangementBtn = document.getElementById('applyArrangement');
const toggleTileLabelsBtn = document.getElementById('toggleTileLabels');
applyArrangementBtn.addEventListener('click', ()=> applyArrangementString(arrangementStr.value||'1 2 3 4 5 6'));
arrangementStr.addEventListener('keydown', (e)=>{ if(e.key==='Enter'){ e.preventDefault(); applyArrangementString(arrangementStr.value||'1 2 3 4 5 6'); }});

toggleTileLabelsBtn.addEventListener('click', ()=>{ showTileLabels=!showTileLabels; autoEvaluateAndRedraw(); });


// ===== Rules =====
/** @typedef {{ id:string, label:string, negated:boolean, within:0|1|2|3, targets:Array<{kind:'terrain',terrain:Terrain[]}|{kind:'animal',animal:Animal[]}|{kind:'structure',type:StructureType[],colors:Color[] }>, players:number[] }} Rule */
const DEFAULT_RULES=(()=>{
	const rules=[];
	let id=1;
	const add=(label,negated,within,targets,players)=>rules.push({id:String(id++),label,negated,within,targets,players});
	
	// Canonical rules 1-48 from the cryptid cluebooks (exact order and text)
	add('not on desert or mountain',true,0,[{kind:'terrain',terrain:['desert','mountain']}],[3,4,5]);
	add('not on desert or swamp',true,0,[{kind:'terrain',terrain:['desert','swamp']}],[3,4,5]);
	add('not on desert or water',true,0,[{kind:'terrain',terrain:['desert','water']}],[3,4,5]);
	add('not on forest or desert',true,0,[{kind:'terrain',terrain:['forest','desert']}],[3,4,5]);
	add('not on forest or mountain',true,0,[{kind:'terrain',terrain:['forest','mountain']}],[3,4,5]);
	add('not on forest or swamp',true,0,[{kind:'terrain',terrain:['forest','swamp']}],[3,4,5]);
	add('not on forest or water',true,0,[{kind:'terrain',terrain:['forest','water']}],[3,4,5]);
	add('not on swamp or mountain',true,0,[{kind:'terrain',terrain:['swamp','mountain']}],[3,4,5]);
	add('not on water or mountains',true,0,[{kind:'terrain',terrain:['water','mountain']}],[3,4,5]);
	add('not on water or swamp',true,0,[{kind:'terrain',terrain:['water','swamp']}],[3,4,5]);
	add('not within one space of desert',true,1,[{kind:'terrain',terrain:['desert']}],[3,4,5]);
	add('not within one space of either animal territory',true,1,[{kind:'animal',animal:['bear','cougar']}],[3,4,5]);
	add('not within one space of forest',true,1,[{kind:'terrain',terrain:['forest']}],[3,4,5]);
	add('not within one space of mountain',true,1,[{kind:'terrain',terrain:['mountain']}],[3,4,5]);
	add('not within one space of swamp',true,1,[{kind:'terrain',terrain:['swamp']}],[3,4,5]);
	add('not within one space of water',true,1,[{kind:'terrain',terrain:['water']}],[3,4,5]);
	add('not within three spaces of a black structure',true,3,[{kind:'structure',type:['standing_stone','abandoned_shack'],colors:['black']}],[3,4,5]);
	add('not within three spaces of a blue structure',true,3,[{kind:'structure',type:['standing_stone','abandoned_shack'],colors:['blue']}],[3,4,5]);
	add('not within three spaces of a green structure',true,3,[{kind:'structure',type:['standing_stone','abandoned_shack'],colors:['green']}],[3,4,5]);
	add('not within three spaces of a white structure',true,3,[{kind:'structure',type:['standing_stone','abandoned_shack'],colors:['white']}],[3,4,5]);
	add('not within two spaces of a standing stone',true,2,[{kind:'structure',type:['standing_stone'],colors:['black','blue','green','white']}],[3,4,5]);
	add('not within two spaces of an abandoned shack',true,2,[{kind:'structure',type:['abandoned_shack'],colors:['black','blue','green','white']}],[3,4,5]);
	add('not within two spaces of bear territory',true,2,[{kind:'animal',animal:['bear']}],[3,4,5]);
	add('not within two spaces of cougar territory',true,2,[{kind:'animal',animal:['cougar']}],[3,4,5]);
	add('on desert or mountain',false,0,[{kind:'terrain',terrain:['desert','mountain']}],[3,4,5]);
	add('on desert or swamp',false,0,[{kind:'terrain',terrain:['desert','swamp']}],[3,4,5]);
	add('on desert or water',false,0,[{kind:'terrain',terrain:['desert','water']}],[3,4,5]);
	add('on forest or desert',false,0,[{kind:'terrain',terrain:['forest','desert']}],[3,4,5]);
	add('on forest or mountain',false,0,[{kind:'terrain',terrain:['forest','mountain']}],[3,4,5]);
	add('on forest or swamp',false,0,[{kind:'terrain',terrain:['forest','swamp']}],[3,4,5]);
	add('on forest or water',false,0,[{kind:'terrain',terrain:['forest','water']}],[3,4,5]);
	add('on swamp or mountain',false,0,[{kind:'terrain',terrain:['swamp','mountain']}],[3,4,5]);
	add('on water or mountains',false,0,[{kind:'terrain',terrain:['water','mountain']}],[3,4,5]);
	add('on water or swamp',false,0,[{kind:'terrain',terrain:['water','swamp']}],[3,4,5]);
	add('within one space of desert',false,1,[{kind:'terrain',terrain:['desert']}],[3,4,5]);
	add('within one space of either animal territory',false,1,[{kind:'animal',animal:['bear','cougar']}],[3,4,5]);
	add('within one space of forest',false,1,[{kind:'terrain',terrain:['forest']}],[3,4,5]);
	add('within one space of mountain',false,1,[{kind:'terrain',terrain:['mountain']}],[3,4,5]);
	add('within one space of swamp',false,1,[{kind:'terrain',terrain:['swamp']}],[3,4,5]);
	add('within one space of water',false,1,[{kind:'terrain',terrain:['water']}],[3,4,5]);
	add('within three spaces of a black structure',false,3,[{kind:'structure',type:['standing_stone','abandoned_shack'],colors:['black']}],[3,4,5]);
	add('within three spaces of a blue structure',false,3,[{kind:'structure',type:['standing_stone','abandoned_shack'],colors:['blue']}],[3,4,5]);
	add('within three spaces of a green structure',false,3,[{kind:'structure',type:['standing_stone','abandoned_shack'],colors:['green']}],[3,4,5]);
	add('within three spaces of a white structure',false,3,[{kind:'structure',type:['standing_stone','abandoned_shack'],colors:['white']}],[3,4,5]);
	add('within two spaces of a standing stone',false,2,[{kind:'structure',type:['standing_stone'],colors:['black','blue','green','white']}],[3,4,5]);
	add('within two spaces of an abandoned shack',false,2,[{kind:'structure',type:['abandoned_shack'],colors:['black','blue','green','white']}],[3,4,5]);
	add('within two spaces of bear territory',false,2,[{kind:'animal',animal:['bear']}],[3,4,5]);
	add('within two spaces of cougar territory',false,2,[{kind:'animal',animal:['cougar']}],[3,4,5]);
	
	return rules;
})();
let RULES=structuredClone(DEFAULT_RULES);

const ruleList=document.getElementById('ruleList'); const playersSel=document.getElementById('players');

function rebuildRuleList(){
	ruleList.innerHTML='';
	const p=+playersSel.value; const subset=RULES.filter(r=>r.players.includes(p));
	subset.forEach((r,i)=>{
		const row=document.createElement('div'); row.className='ruleItem'; row.dataset.id=r.id;
		const label=document.createElement('div'); label.textContent=r.label; label.style.cursor='pointer';
		const count=document.createElement('div'); count.id=`rc_${r.id}`; count.className='small'; count.textContent='';
		
		// Make rule selectable
		row.style.cursor='pointer';
		row.addEventListener('click', ()=>{
			// Clear previous selection
			document.querySelectorAll('.ruleItem').forEach(item => {
				item.style.backgroundColor = '';
				item.style.border = '';
			});
			
			// Toggle selection
			if(selectedRuleId === r.id){
				selectedRuleId = null;
				row.style.backgroundColor = '';
				row.style.border = '';
			} else {
				selectedRuleId = r.id;
				row.style.backgroundColor = '#0b1220';
				row.style.border = '2px solid #22d3ee';
			}
			
			// Redraw with selected rule highlighted
			redrawWithSelection();
		});
		
		// Restore selection visual state if this rule is selected
		if(selectedRuleId === r.id){
			row.style.backgroundColor = '#0b1220';
			row.style.border = '2px solid #22d3ee';
		}
		
		row.appendChild(label); row.appendChild(count);ruleList.appendChild(row);
	});
}

// counts for all visible rules (auto)
function updateRuleCounts(){
	const p=+playersSel.value; const subset=RULES.filter(r=>r.players.includes(p));
	subset.forEach(r=>{ const s=evalRule(r); const el=document.getElementById(`rc_${r.id}`); if(el) el.textContent=String(s.size); });
}

// ===== Players & assignments =====
function visibleRules(){ const p=+playersSel.value; return RULES.filter(r=>r.players.includes(p)); }
function rebuildAssignmentsUI(){
	const host=document.getElementById('assignments'); if(!host) return; host.innerHTML='';
	const p=+playersSel.value;
	const defaultColors = DEFAULT_PLAYER_COLORS_BY_COUNT[p] || PLAYER_COLOR_ORDER.slice(0,p);
	// Get current config for this player count
	const currentConfig = GAME_CONFIGURATIONS[p] || [];
	
	if(PLAYER_ASSIGNMENTS.length!==p){
		PLAYER_ASSIGNMENTS = Array.from({length:p}, (_,i)=>{
			const configItem = currentConfig[i];
			if(configItem) {
				return {
					color: configItem.color,
					clueNumber: configItem.clueNumber,
					ruleId: resolveRuleFromClue(configItem.color, configItem.clueNumber)
				};
			} else {
				return {
					color: defaultColors[i]||PLAYER_COLOR_ORDER[i], 
					ruleId: null,
					clueNumber: null
				};
			}
		});
	} else {
		PLAYER_ASSIGNMENTS.forEach((a,i)=>{ 
			const configItem = currentConfig[i];
			if(configItem && (!a || !a.color)) {
				PLAYER_ASSIGNMENTS[i] = {
					color: configItem.color,
					clueNumber: configItem.clueNumber,
					ruleId: resolveRuleFromClue(configItem.color, configItem.clueNumber)
				};
			} else if(!a||!a.color){ 
				PLAYER_ASSIGNMENTS[i]={ 
					color: defaultColors[i]||PLAYER_COLOR_ORDER[i], 
					ruleId: a?a.ruleId:null,
					clueNumber: a?a.clueNumber:null
				}; 
			} 
		});
	}
	
	PLAYER_ASSIGNMENTS.forEach((a,idx)=>{
		const row=document.createElement('div'); row.className='row'; 
		// Add spacing between player rows, except for the last one
		if (idx < PLAYER_ASSIGNMENTS.length - 1) {
			row.style.marginBottom='24px';
		}
		const label=document.createElement('label'); label.textContent=`Player ${idx+1}`; label.style.minWidth='70px';
		const chip=document.createElement('span'); chip.className='colorChip'; chip.style.background=PLAYER_COLORS[a.color]; chip.style.margin='0 6px';
		
		const colorSel=document.createElement('select');
		PLAYER_COLOR_ORDER.forEach(c=>{ const opt=document.createElement('option'); opt.value=c; opt.textContent=c; opt.selected=(a.color===c); colorSel.appendChild(opt); });
		colorSel.addEventListener('change', ()=>{ 
			a.color=colorSel.value; 
			chip.style.background=PLAYER_COLORS[a.color]; 
			// Re-resolve rule when color changes
			if (a.clueNumber) {
				const newRuleId = resolveRuleFromClue(a.color, a.clueNumber);
				a.ruleId = newRuleId;
				updateRuleDisplay(a, ruleDisplay, cellCount);
			}
			// Save current assignments to game configurations
			saveCurrentAssignmentsToConfig();
			// Auto-evaluate and redraw
			autoEvaluateAndRedraw();
		});
		
		const clueInput=document.createElement('input');
		clueInput.type='number';
		clueInput.min='1';
		clueInput.max='96';
		clueInput.placeholder='1-96';
		clueInput.style.width='60px';
		clueInput.style.marginLeft='6px';
		if (a.clueNumber) clueInput.value = a.clueNumber;
		
		const ruleDisplay=document.createElement('span');
		ruleDisplay.style.fontSize='12px';
		ruleDisplay.style.color='var(--muted)';
		ruleDisplay.style.marginLeft='6px';
		ruleDisplay.style.cursor='pointer';
		ruleDisplay.style.textDecoration='underline';
		
		const cellCount=document.createElement('span');
		cellCount.style.fontSize='12px';
		cellCount.style.color='var(--muted)';
		cellCount.style.marginLeft='6px';
		cellCount.style.fontWeight='bold';
		
		function updateRuleDisplay(assignment, displayElement, countElement) {
			if (assignment.ruleId) {
				const rule = RULES.find(r => r.id === assignment.ruleId);
				if (rule) {
					displayElement.textContent = rule.label;
					// Calculate cell count
					const cellSet = evalRule(rule);
					countElement.textContent = `(${cellSet.size})`;
					
					// Make clickable to select in rule list
					displayElement.onclick = () => {
						// Clear previous selection
						document.querySelectorAll('.ruleItem').forEach(item => {
							item.style.backgroundColor = '';
							item.style.border = '';
						});
						
						// Select this rule in the list
						selectedRuleId = rule.id;
						const ruleItem = document.querySelector(`.ruleItem[data-id="${rule.id}"]`);
						if (ruleItem) {
							ruleItem.style.backgroundColor = '#0b1220';
							ruleItem.style.border = '2px solid #22d3ee';
						}
						
						// Redraw with selected rule highlighted
						redrawWithSelection();
					};
				} else {
					displayElement.textContent = '(unknown rule)';
					countElement.textContent = '';
					displayElement.onclick = null;
				}
			} else {
				displayElement.textContent = '';
				countElement.textContent = '';
				displayElement.onclick = null;
			}
		}
		
		clueInput.addEventListener('input', ()=>{ 
			const clueNum = parseInt(clueInput.value, 10);
			if (clueNum >= 1 && clueNum <= 96) {
				a.clueNumber = clueNum;
				const ruleId = resolveRuleFromClue(a.color, clueNum);
				a.ruleId = ruleId;
				updateRuleDisplay(a, ruleDisplay, cellCount);
			} else {
				a.clueNumber = null;
				a.ruleId = null;
				ruleDisplay.textContent = '';
				cellCount.textContent = '';
			}
			// Save current assignments to game configurations
			saveCurrentAssignmentsToConfig();
			// Auto-evaluate and redraw
			autoEvaluateAndRedraw();
			// Check for auto-capture
			checkAutoCapture();
		});
		
		// Initial rule display
		updateRuleDisplay(a, ruleDisplay, cellCount);
		
		// Add show/hide eye toggle
		const eyeToggle = document.createElement('button');
		eyeToggle.type = 'button';
		eyeToggle.className = 'eye-toggle';
		eyeToggle.id = `showPlayer${idx}`;
		
		// Start with "hidden" state (eye closed) - use data attribute for compatibility
		eyeToggle.dataset.visible = 'false';
		
		function updateEyeIcon() {
			const isVisible = eyeToggle.dataset.visible === 'true';
			eyeToggle.innerHTML = isVisible 
				? `<svg viewBox="0 0 24 24"><path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/></svg>`
				: `<svg viewBox="0 0 24 24"><path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"/></svg>`;
		}
		
		updateEyeIcon();
		
		eyeToggle.addEventListener('click', () => {
			const currentVisible = eyeToggle.dataset.visible === 'true';
			eyeToggle.dataset.visible = (!currentVisible).toString();
			updateEyeIcon();
			autoEvaluateAndRedraw();
		});
		
		row.appendChild(eyeToggle);
		row.appendChild(chip);
		row.appendChild(label); 
		row.appendChild(colorSel); 
		row.appendChild(clueInput);
		row.appendChild(ruleDisplay);
		row.appendChild(cellCount);
		host.appendChild(row);
	});
}

// ===== Game Hint Display =====
function updateHintDisplay() {
	const hintDisplay = document.getElementById('hintDisplay');
	const p = +playersSel.value;
	const hintNumber = GAME_HINTS[p];
	
	if (!hintNumber || hintNumber < 1 || hintNumber > 80) {
		hintDisplay.innerHTML = '<div class="small">No hint assigned for this player count.</div>';
		return;
	}
	
	const hintDescription = HINT_DESCRIPTIONS[hintNumber];
	
	hintDisplay.innerHTML = `
		<div class="row">
			<input type="number" id="hintInput" min="1" max="80" value="${hintNumber}" style="width: 60px;" placeholder="1-80">
			<span style="font-size: 12px; color: var(--muted); margin-left: 6px;">${hintDescription}</span>
		</div>
	`;
	
	// Add event listener for hint input changes
	const hintInput = document.getElementById('hintInput');
	hintInput.addEventListener('input', () => {
		const newHintNumber = parseInt(hintInput.value, 10);
		if (newHintNumber >= 1 && newHintNumber <= 80) {
			GAME_HINTS[p] = newHintNumber;
			updateHintDisplay(); // Refresh to show new description
			checkAutoCapture(); // Check for auto-capture
		}
	});
}

// ===== Automatic Evaluation =====
function evalRule(rule){
	const good=new Set();
	forEachCell(c=>{
		let hit=false;
		for(const t of rule.targets){
			if(t.kind==='terrain'){
				if(rule.within===0){ if(t.terrain.includes(c.terrain)) hit=true; }
				else { forEachCell(c2=>{ if(!hit && t.terrain.includes(c2.terrain) && hexDist(c,c2)<=rule.within) hit=true; }); }
			} else if(t.kind==='animal'){
				if(rule.within>0){ forEachCell(c2=>{ if(!hit){ const has=t.animal.some(a=>c2.animals.has(a)); if(has && hexDist(c,c2)<=rule.within) hit=true; } }); }
			} else if(t.kind==='structure'){
				if(rule.within>0){ forEachCell(c2=>{ if(!hit){ const any=c2.structures.some(s=>t.type.includes(s.type)&&t.colors.includes(s.color)); if(any && hexDist(c,c2)<=rule.within) hit=true; } }); }
			}
			if(hit) break;
		}
		const ok=rule.negated?!hit:hit;
		if(ok) good.add(key(c.q,c.r));
	});
	return good;
}

let latestPerRule=null, latestUniqueKey=null;
let selectedRuleId=null; // Track the currently selected rule for inspection

function autoEvaluateAndRedraw(){
	const p=+playersSel.value; const subset=RULES.filter(r=>r.players.includes(p));
	const byId=new Map(subset.map(r=>[r.id,r]));
	
	// Get active assignments with their original indices
	const activeAssignments = PLAYER_ASSIGNMENTS.map((a,idx)=>({...a, originalIndex:idx})).filter(a=>a.ruleId);
	const act = activeAssignments.map(a=>byId.get(a.ruleId)).filter(Boolean);
	
	if(act.length===0){ 
		latestPerRule=null; 
		latestUniqueKey=null; 
		habitatCellSet=null;
		redrawWithSelection(); 
		updateBalanceAnalysis(p, []);
		return; 
	}
	
	const per = act.map((r,i)=>[r, evalRule(r), activeAssignments[i]]);
	per.forEach(([r,s])=>{ const el=document.getElementById(`rc_${r.id}`); if(el) el.textContent=`${s.size}`; });
	
	// Only show overlays for players whose eye toggles are visible
	const overlays = per.filter(([r,s,assignment]) => {
		const eyeToggle = document.getElementById(`showPlayer${assignment.originalIndex}`);
		return eyeToggle && eyeToggle.dataset.visible === 'true';
	}).map(([r,s,assignment])=>({id:r.id,set:s,color: PLAYER_COLORS[assignment.color] }));
	
	// Always calculate habitat intersection regardless of checkboxes
	let acc=null; per.forEach(([_,s])=>{ acc = acc? intersect(acc,s): s; });
	const uniqKey=acc.size===1?[...acc][0]:null;
	
	// Store habitat cells for visualization
	habitatCellSet = acc;
	
	latestPerRule=overlays; latestUniqueKey=uniqKey; redrawWithSelection();
	
	// Update balance analysis for 4-player games
	updateBalanceAnalysis(p, per);
}

function intersect(a,b){ const out=new Set(); for(const v of a) if(b.has(v)) out.add(v); return out; }

// ===== Balance Analysis for 4-Player Games =====
function updateBalanceAnalysis(playerCount, playerRuleData) {
	const balancePanel = document.getElementById('balanceAnalysis');
	const balanceResults = document.getElementById('balanceResults');
	
	if (playerCount !== 4 || playerRuleData.length !== 4) {
		balancePanel.style.display = 'none';
		return;
	}
	
	balancePanel.style.display = 'block';
	
	// Extract rule sets and assignments for easier reference
	const rules = playerRuleData.map(([rule, ruleSet, assignment]) => ({
		rule,
		ruleSet,
		assignment,
		label: `P${assignment.originalIndex + 1}`,
		colorCircle: `<span class="colorChip" style="background: ${PLAYER_COLORS[assignment.color]}; display: inline-block; width: 12px; height: 12px; border-radius: 50%; margin: 0 2px; vertical-align: middle;"></span>`
	}));
	
	// Calculate all 6 pairwise intersections
	const pairIntersections = [];
	for (let i = 0; i < 4; i++) {
		for (let j = i + 1; j < 4; j++) {
			const intersection = intersect(rules[i].ruleSet, rules[j].ruleSet);
			pairIntersections.push({
				players: [i, j],
				labels: [rules[i].label, rules[j].label],
				count: intersection.size,
				intersection
			});
		}
	}
	
	// Calculate the 3 possible team pairings
	const teamPairings = [
		{ teams: [[0,1], [2,3]], labels: [rules[0].colorCircle + rules[1].colorCircle, rules[2].colorCircle + rules[3].colorCircle] },
		{ teams: [[0,2], [1,3]], labels: [rules[0].colorCircle + rules[2].colorCircle, rules[1].colorCircle + rules[3].colorCircle] },
		{ teams: [[0,3], [1,2]], labels: [rules[0].colorCircle + rules[3].colorCircle, rules[1].colorCircle + rules[2].colorCircle] }
	];
	
	let html = '';
	
	// Show team pairing analysis
	teamPairings.forEach((pairing, idx) => {
		const team1Intersection = intersect(rules[pairing.teams[0][0]].ruleSet, rules[pairing.teams[0][1]].ruleSet);
		const team2Intersection = intersect(rules[pairing.teams[1][0]].ruleSet, rules[pairing.teams[1][1]].ruleSet);
		
		const diff = Math.abs(team1Intersection.size - team2Intersection.size);
		const balanceClass = diff <= 2 ? 'color: var(--muted)' : diff <= 5 ? 'color: #eab308' : 'color: #ef4444';
		
		// Add top margin to first item to create proper spacing from legend
		const marginTop = idx === 0 ? 'margin-top: 10px;' : '';
		html += `<div style="font-size: 12px; margin: 4px 0; ${marginTop} ${balanceClass};">`;
		html += `${idx + 1}. ${pairing.labels[0]} (${team1Intersection.size}) vs ${pairing.labels[1]} (${team2Intersection.size}) - Diff: ${diff}`;
		html += '</div>';
	});
	html += '</div>';
	
	balanceResults.innerHTML = html;
}

const showHabitatCheckbox = document.getElementById('showHabitat');
showHabitatCheckbox.addEventListener('change', ()=>{ redrawWithSelection(); });
playersSel.addEventListener('change', ()=>{ 
	// Clear rule selection if the currently selected rule is not available for the new player count
	if(selectedRuleId) {
		const p = +playersSel.value;
		const availableRules = RULES.filter(r => r.players.includes(p));
		if(!availableRules.find(r => r.id === selectedRuleId)) {
			selectedRuleId = null;
		}
	}
	rebuildRuleList(); rebuildAssignmentsUI(); 
	updatePlayerAssignmentsFromConfig(); // Load saved config for this player count
	rebuildAssignmentsUI(); // Rebuild again with the loaded config
	updateHintDisplay(); // Update hint display for new player count
	autoEvaluateAndRedraw(); // Auto-evaluate instead of just redrawWithSelection
});

// ===== Structure palette =====
function buildStructurePalette(){
	const host = document.getElementById('structurePalette');
	if(!host) return;
	
	host.innerHTML = '';
	
	// Reorder colors: blue, green, white, black (black last)
	const colorOrder = ['blue', 'green', 'white', 'black'];
	
	// Create 2x4 grid: same color structures side by side
	colorOrder.forEach(color => {
		// Create a row container for this color's structures
		const rowDiv = document.createElement('div');
		rowDiv.style.display = 'contents'; // Use CSS grid layout
		
		STRUCT_TYPES.forEach(type => {
			const btn = document.createElement('button');
			btn.className = 'inline';
			btn.style.margin = '0';
			btn.style.padding = '4px';
			btn.style.width = '100%';
			btn.style.height = '48px';
			btn.style.background = '#374151';
			btn.style.border = '1px solid #666';
			btn.style.borderRadius = '4px';
			btn.style.display = 'flex';
			btn.style.alignItems = 'center';
			btn.style.justifyContent = 'center';
			
			// Create SVG for the structure symbol
			const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
			svg.setAttribute('width', '36');
			svg.setAttribute('height', '36');
			svg.setAttribute('viewBox', '-18 -18 36 36');
			
			const shape = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
			
			if(type === 'standing_stone'){
				// Octagon (8 sides, rotated 22.5 degrees like in the board)
				shape.setAttribute('points', regularPolygonPoints(0, 0, 15, 8, 22.5));
			} else {
				// Triangle (3 sides, rotated -90 degrees like in the board)
				shape.setAttribute('points', regularPolygonPoints(0, 0, 15, 3, -90));
			}
			
			shape.setAttribute('fill', STRUCT_COLORS[color]);
			shape.setAttribute('stroke', '#000');
			shape.setAttribute('stroke-width', '1.5');
			
			svg.appendChild(shape);
			btn.appendChild(svg);
			
			btn.addEventListener('click', () => {
				// Clear previous selection
				document.querySelectorAll('#structurePalette button').forEach(b => {
					b.style.boxShadow = '';
				});
				
				// Toggle selection
				if(currentStructureType === type && currentStructureColor === color){
					currentStructureType = null;
					currentStructureColor = null;
				} else {
					currentStructureType = type;
					currentStructureColor = color;
					btn.style.boxShadow = '0 0 0 2px #22d3ee';
				}
			});
			
			host.appendChild(btn);
		});
	});
}

// ===== Bootstrap =====
function boot()
{
	loadDefaultGame();
	rebuildRuleList();
	rebuildAssignmentsUI();
	buildStructurePalette();
	updateHintDisplay();
	autoEvaluateAndRedraw();
}

// Poll until GAMES is ready
const interval = setInterval(() =>
{
	if (window.GAMES !== null)
	{
		clearInterval(interval);
		boot();
	}
}, 100);

</script>
</body>
</html>
